<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SB3 - Scanner Box 3</title>
  <style>
    :root {
      --bg-dark: #0a0d11;
      --bg-card: #0f1318;
      --bg-panel: #121618;
      --text-primary: #e4e8f0;
      --text-secondary: #8a92a8;
      --accent: #2dd4bf;
      --accent-dim: rgba(45, 212, 191, 0.3);
      --accent-glow: rgba(45, 212, 191, 0.15);
      --border: #141a21;
      --good: #10b981;
      --bad: #ef4444;
      --warn: #f59e0b;
      --slider-track: rgba(45, 212, 191, 0.08);
      --slider-glow: 0 0 8px rgba(45, 212, 191, 0.25), inset 0 1px 2px rgba(45, 212, 191, 0.1);
    }

    /* Red theme for dark environments */
    body.red-theme {
      --accent: #8a2222;
      --accent-dim: rgba(138, 34, 34, 0.35);
      --accent-glow: rgba(138, 34, 34, 0.14);
      --good: #8a2222;
      --slider-track: rgba(138, 34, 34, 0.14);
      --slider-glow: 0 0 6px rgba(138, 34, 34, 0.24), inset 0 1px 2px rgba(138, 34, 34, 0.14);
      --text-primary: #4f5666;
      --text-secondary: #3f4654;
      --border: #07090c;
      --bg-dark: #06080b;
      --bg-panel: #080b0f;
      --bg-card: #070a0e;
    }

    body.red-theme select {
      background: var(--bg-panel);
      color: #c7cedb;
      border-color: var(--border);
    }

    body.red-theme input[type="text"],
    body.red-theme input:not([type]) {
      background: var(--bg-panel);
      color: #c7cedb;
      border-color: var(--border);
    }

    body.red-theme textarea {
      background: var(--bg-panel);
      color: #c7cedb;
      border-color: var(--border);
    }

    body.red-theme .widget,
    body.red-theme .control-item,
    body.red-theme .profile-btn,
    body.red-theme .last-hit-btn,
    body.red-theme .tab,
    body.red-theme .player-box,
    body.red-theme .status-indicators {
      border-color: var(--border);
      box-shadow: none;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      font-size: 14px;
      min-height: 100vh;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px 16px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 100;
      position: relative;
    }

    .header-left {
      position: absolute;
      left: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-right {
      position: absolute;
      right: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 1px;
      color: var(--accent);
      text-transform: uppercase;
      padding: 4px 8px;
      border: 1px solid var(--accent);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      font: inherit;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .logo-tag {
      font-size: 9px;
      letter-spacing: 0.12em;
      color: var(--text-secondary);
      border-left: 1px solid var(--border);
      padding-left: 6px;
    }

    body.sitrep-mode .logo-tag {
      color: var(--accent);
      border-left-color: var(--accent-dim);
    }

    .logo:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .status-indicators {
      display: flex;
      gap: 12px;
      font-size: 12px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--bad);
    }

    .status-dot.active {
      background: var(--good);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .hidden {
      display: none !important;
    }

    .last-hit-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      width: min(660px, 70vw);
      max-width: calc(100% - 160px);
      justify-content: center;
    }

    .last-hit-btn {
      display: grid;
      gap: 4px;
      min-width: 90px;
      flex: 1 1 0;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      color: var(--text);
      cursor: pointer;
      text-align: center;
      align-items: center;
      justify-items: center;
      transition: color 0.15s ease, border-color 0.15s ease;
    }

    .last-hit-btn .label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-secondary);
    }

    .last-hit-btn .value {
      font-family: monospace;
      font-size: 20px;
      font-weight: 600;
      color: var(--accent);
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .last-hit-btn.holding .value {
      color: var(--warn);
    }

    .connection-status {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
      background: var(--bg-panel);
    }

    .connection-status.connected { color: var(--good); }
    .connection-status.disconnected { color: var(--bad); }

    .theme-toggle {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      margin-left: 8px;
    }

    .theme-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    body.red-theme .theme-toggle {
      background: var(--accent-dim);
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Main Layout */
    .main {
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .grid-full {
      grid-column: 1 / -1;
    }

    .view-stack {
      perspective: 1400px;
    }

    .view {
      transform-style: preserve-3d;
      transform-origin: left center;
    }

    .view.hidden {
      display: none;
    }

    .view.flip-in {
      animation: flipIn 0.45s ease;
    }

    .view.flip-out {
      animation: flipOut 0.45s ease forwards;
    }

    @keyframes flipIn {
      from { opacity: 0; transform: rotateY(-90deg); }
      to { opacity: 1; transform: rotateY(0deg); }
    }

    @keyframes flipOut {
      from { opacity: 1; transform: rotateY(0deg); }
      to { opacity: 0; transform: rotateY(90deg); }
    }

    /* Widget */
    .widget {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }

    .widget.collapsed .widget-body {
      display: none;
    }

    .widget-header {
      padding: 12px 16px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
    }

    .widget-header.with-actions {
      gap: 8px;
    }

    .widget-header-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
    }

    .widget-header-action {
      flex: 0 0 auto !important;
      padding: 6px 10px !important;
      font-size: 10px !important;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .loop-indicator {
      display: inline-flex;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 10px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--text-secondary);
      white-space: nowrap;
      background: rgba(255, 255, 255, 0.02);
    }

    .loop-indicator.good {
      border-color: rgba(16, 185, 129, 0.5);
      color: var(--good);
    }

    .loop-indicator.warn {
      border-color: rgba(245, 158, 11, 0.5);
      color: var(--warn);
    }

    .loop-indicator.bad {
      border-color: rgba(239, 68, 68, 0.5);
      color: var(--bad);
    }

    .widget-body {
      padding: 16px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-left: auto;
    }

    .tab {
      padding: 4px 12px;
      font-size: 11px;
      font-weight: 500;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .tab:hover {
      border-color: var(--accent);
      color: var(--text-primary);
    }

    .tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--bg-dark);
    }

    /* Controls */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .control-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .control-value {
      font-family: monospace;
      color: var(--accent);
    }

    .control-applied {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--slider-track);
      box-shadow: var(--slider-glow);
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid var(--bg-dark);
    }

    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid var(--bg-dark);
      cursor: pointer;
    }

    .slider.dirty {
      background: linear-gradient(90deg, var(--accent-dim), var(--bg-panel));
    }

    /* Profiles */
    .profiles-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      max-height: 360px;
      overflow-y: auto;
      padding-right: 4px; /* room for scrollbar */
      scrollbar-gutter: stable;
    }
    .profiles-grid::-webkit-scrollbar { width: 10px; }
    .profiles-grid::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,.10);
      border-radius: 999px;
    }
    .profiles-grid::-webkit-scrollbar-track { background: transparent; }

    .profile-btn {
      padding: 10px 12px;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 12px;
      text-align: left;
      transition: all 0.15s;
    }

    .profile-btn:hover {
      border-color: var(--accent);
    }

    .profile-btn.active {
      border-color: var(--accent);
      background: var(--accent-dim);
    }

    .profile-btn .label {
      font-weight: 500;
    }

    .profile-btn .meta {
      font-size: 10px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .profile-loop-panel {
      margin-top: 12px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.14);
      display: grid;
      gap: 8px;
    }

    .profile-sidecar .profile-loop-panel {
      margin-top: 0;
      background: rgba(16, 22, 28, 0.72);
    }

    .loop-checklist {
      max-height: 156px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      background: var(--bg-panel);
      display: grid;
      gap: 6px;
    }

    .loop-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-primary);
    }

    .loop-item .meta {
      color: var(--text-secondary);
      font-size: 10px;
    }

    .loop-controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .loop-controls label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .loop-controls input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      color: var(--text-primary);
      font-size: 12px;
    }

    .loop-checkbox-label {
      justify-content: center;
      gap: 6px;
      flex-direction: row !important;
      align-items: center;
    }

    .player-box {
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      border: 1px solid var(--border);
      /* Encourage browsers to render native media controls in a dark theme. */
      color-scheme: dark;
    }
    .player-box audio {
      width: 100%;
      margin-top: 6px;
      height: 36px;
      border-radius: 999px;
      /* Native <audio> controls are mostly UA-drawn; this makes them less "giant white pill". */
      color-scheme: dark;
      opacity: 0.88;
    }

    .freq-editor textarea {
      width: 100%;
      box-sizing: border-box;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.30);
      color: var(--text-primary);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.35;
      resize: vertical;
      color-scheme: dark;
    }
    .freq-editor.collapsed .freq-edit-body {
      display: none;
    }
    .freq-editor textarea:focus { outline: 2px solid var(--accent-dim); outline-offset: 2px; }

    /* Counters */
    .counter-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .counter-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .counter-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--accent);
      font-family: monospace;
    }

    .counter-rate {
      font-size: 11px;
      color: var(--good);
      margin-top: 4px;
    }

    /* Hit List */
    .hit-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-height: 360px;
      max-height: 360px;
      overflow-y: auto;
    }

    .hit-row {
      display: grid;
      grid-template-columns: 70px 56px 1fr 50px;
      gap: 8px;
      padding: 8px 10px;
      background: var(--bg-panel);
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }

    .hit-row .time { color: var(--text-secondary); }
    .hit-row .src { color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.04em; }
    .hit-row .freq { color: var(--accent); }
    .hit-row .duration { color: var(--text-secondary); text-align: right; }

    .hit-row.header {
      background: transparent;
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
    }

    /* Buttons */
    .btn-row {
      display: flex;
      gap: 6px;
      margin-top: 12px;
    }

    button.action {
      flex: 1;
      padding: 10px 16px;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.15s;
      -webkit-tap-highlight-color: transparent;
    }

    button.action:hover { border-color: var(--accent); }
    button.action:disabled { opacity: 0.5; cursor: not-allowed; }
    button.action:focus,
    button.action:focus-visible,
    button.action:active {
      outline: none;
      border-color: var(--border);
      box-shadow: none;
    }

    /* ADS-B */
    .adsb-frame {
      width: 100%;
      aspect-ratio: 1 / 1;
      border: none;
      border-radius: 4px;
      background: var(--bg-panel);
    }

    .adsb-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 400px;
      color: var(--text-secondary);
      gap: 12px;
    }

    .adsb-placeholder .icon {
      font-size: 48px;
    }

    /* Dialog */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .modal-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      width: 260px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .modal-card h3 {
      margin-bottom: 12px;
      font-size: 14px;
      color: var(--text-primary);
    }
    .modal-card input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-panel);
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 12px;
    }
    .modal-actions {
      display: flex;
      gap: 8px;
    }
    .modal-actions button {
      flex: 1;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-panel);
      color: var(--text-primary);
      cursor: pointer;
    }
    .modal-actions button.confirm {
      border-color: var(--accent);
      color: var(--bg-dark);
      background: var(--accent);
    }

    .sidecar-toggle {
      min-width: 72px;
    }

    .profile-sidecar-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      z-index: 998;
    }

    .profile-sidecar {
      position: fixed;
      top: 0;
      right: 0;
      width: min(720px, 96vw);
      height: 100vh;
      z-index: 999;
      background: linear-gradient(180deg, rgba(16, 20, 26, 0.98), rgba(9, 13, 18, 0.98));
      border-left: 1px solid var(--border);
      box-shadow: -20px 0 40px rgba(0, 0, 0, 0.45);
      transform: translateX(102%);
      transition: transform 0.22s ease;
      display: grid;
      grid-template-rows: auto auto 1fr;
    }

    .profile-sidecar.open {
      transform: translateX(0);
    }

    .profile-sidecar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(15, 20, 25, 0.85);
    }

    .profile-sidecar-title {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-primary);
    }

    .profile-sidecar-sub {
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 0.04em;
      margin-top: 2px;
    }

    .profile-sidecar-tabs {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(14, 18, 24, 0.72);
    }

    .profile-sidecar-tab-group {
      display: flex;
      gap: 8px;
      min-width: 0;
    }

    .profile-sidecar-tab {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-panel);
      color: var(--text-primary);
      padding: 7px 12px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
    }

    .profile-sidecar-tab.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.24) inset;
    }

    .profile-sidecar-load {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;
      padding: 7px 12px;
    }

    .profile-sidecar-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .profile-sidecar-body {
      overflow: auto;
      padding: 12px 14px 20px;
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .profile-sidecar-panel {
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .profile-editor-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: rgba(16, 22, 28, 0.72);
      display: grid;
      gap: 9px;
    }

    .profile-editor-card .control-label {
      margin-bottom: 0;
    }

    .profile-editor-card input,
    .profile-editor-card select,
    .profile-editor-card textarea {
      width: 100%;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 7px;
      color: var(--text-primary);
      padding: 7px 9px;
      font-size: 12px;
      font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    .profile-editor-card textarea {
      min-height: 130px;
      resize: vertical;
      line-height: 1.32;
    }

    .profile-editor-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .profile-editor-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .profile-editor-pill {
      display: inline-flex;
      align-items: center;
      border: 1px solid rgba(245, 158, 11, 0.45);
      border-radius: 999px;
      color: #f59e0b;
      font-size: 10px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 3px 7px;
    }

    .profile-editor-status {
      font-size: 12px;
      min-height: 18px;
      color: var(--text-secondary);
    }

    .profile-editor-launch {
      margin-top: 8px;
      width: 100%;
      justify-content: center;
      border-color: rgba(45, 212, 191, 0.45);
      color: var(--accent);
    }

    .system-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .system-item {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 10px;
      display: grid;
      gap: 4px;
    }
    .system-item .label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-secondary);
    }
    .system-item .value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .system-item .sub {
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-secondary);
    }

    .empty-state .icon {
      font-size: 32px;
      margin-bottom: 12px;
    }

    /* Sitrep */
    .sitrep {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 16px 40px;
      position: relative;
    }

    .sitrep::before {
      content: '';
      position: absolute;
      inset: 0;
      background:
        radial-gradient(900px 320px at 12% -10%, rgba(45, 212, 191, 0.12), transparent),
        radial-gradient(700px 240px at 90% 0%, rgba(45, 212, 191, 0.08), transparent);
      pointer-events: none;
      z-index: 0;
    }

    .sitrep > * {
      position: relative;
      z-index: 1;
    }

    .sitrep-header {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 24px;
    }

    .sitrep-eyebrow {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.32em;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .sitrep-headline {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 0.04em;
      margin-bottom: 6px;
    }

    .sitrep-meta {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .sitrep-summary {
      display: grid;
      gap: 8px;
      justify-items: end;
    }

    .sitrep-chip {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(18, 22, 24, 0.8);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .sitrep-chip.good {
      border-color: var(--good);
      color: var(--good);
    }

    .sitrep-chip.bad {
      border-color: var(--bad);
      color: var(--bad);
    }

    .sitrep-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .sitrep-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      display: grid;
      gap: 12px;
      min-height: 160px;
      align-content: start;
    }

    .sitrep-card-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-secondary);
    }

    .metric-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      align-content: start;
    }

    .metric-item {
      display: grid;
      gap: 4px;
    }

    .metric-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .metric-value {
      font-size: 18px;
      font-weight: 700;
      font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: var(--text-primary);
    }

    .metric-sub {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .service-list {
      display: grid;
      gap: 10px;
    }

    .service-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(18, 22, 24, 0.7);
    }

    .service-name {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .service-meta {
      font-size: 11px;
      color: var(--text-secondary);
      font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    .service-meta.warn {
      color: var(--warn);
    }

    .service-meta.bad {
      color: var(--bad);
    }

    .service-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--text-secondary);
      box-shadow: 0 0 10px rgba(45, 212, 191, 0.08);
    }

    .digital-status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .digital-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--bad);
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.25);
    }

    .digital-dot.active {
      background: var(--good);
      box-shadow: 0 0 10px rgba(16, 185, 129, 0.35);
    }

    .digital-preview {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: rgba(18, 22, 24, 0.6);
    }

    .digital-preview.collapsed .digital-preview-body {
      display: none;
    }

    .digital-preview textarea {
      width: 100%;
      min-height: 160px;
      background: var(--bg-panel);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      resize: vertical;
    }

    .digital-listen {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: rgba(18, 22, 24, 0.6);
    }

    .digital-listen.collapsed .digital-listen-body {
      display: none;
    }

    .digital-listen-toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 8px;
    }

    .digital-listen-toolbar input,
    .digital-listen-toolbar select {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      color: var(--text-primary);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 12px;
    }

    .digital-listen-list {
      max-height: 280px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-panel);
    }

    .digital-listen-row {
      display: grid;
      grid-template-columns: 28px 78px 52px 1fr 140px;
      gap: 8px;
      align-items: center;
      padding: 6px 10px;
      border-bottom: 1px solid rgba(20, 26, 33, 0.8);
      font-size: 12px;
    }

    .digital-listen-row-head {
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(10, 14, 18, 0.95);
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 10px;
      color: var(--text-secondary);
      font-weight: 700;
    }

    .digital-listen-sort {
      appearance: none;
      border: none;
      background: transparent;
      color: inherit;
      font: inherit;
      text-transform: inherit;
      letter-spacing: inherit;
      font-size: inherit;
      font-weight: inherit;
      cursor: pointer;
      padding: 0;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .digital-listen-sort .arrow {
      opacity: 0.6;
      font-size: 9px;
      line-height: 1;
    }

    .digital-listen-sort.active .arrow {
      opacity: 1;
      color: var(--accent-cyan);
    }

    .digital-listen-row:last-child {
      border-bottom: none;
    }

    .digital-listen-row .muted {
      color: var(--text-secondary);
    }
    .digital-listen-row .rejected {
      color: #f59e0b;
      font-weight: 600;
    }

    .service-item.online {
      border-color: rgba(16, 185, 129, 0.5);
    }

    .service-item.online .service-dot {
      background: var(--good);
      box-shadow: 0 0 12px rgba(16, 185, 129, 0.4);
    }

    .service-item.offline {
      border-color: rgba(239, 68, 68, 0.4);
    }

    .service-item.offline .service-dot {
      background: var(--bad);
      box-shadow: 0 0 12px rgba(239, 68, 68, 0.35);
    }

    .config-grid {
      display: grid;
      gap: 8px;
      align-content: start;
    }

    .config-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(30, 37, 48, 0.6);
    }

    .config-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .config-label {
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .config-value {
      font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: var(--text-primary);
    }

    .config-value.good {
      color: #2be3a8;
    }

    .config-value.warn {
      color: #f7c66f;
    }

    .config-value.bad {
      color: #ff6b6b;
    }

    .activity-log {
      background: #0b0f14;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      max-height: 220px;
      overflow: auto;
      font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      line-height: 1.4;
      display: grid;
      gap: 6px;
    }

    .log-row {
      display: flex;
      align-items: baseline;
      gap: 8px;
      color: var(--text-secondary);
    }

    .log-time {
      color: var(--accent);
      min-width: 70px;
    }

    .log-level {
      font-size: 10px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .log-level.warn {
      color: var(--warn);
    }

    .log-level.error {
      color: var(--bad);
    }

    .log-message {
      color: var(--text-primary);
    }

    .log-empty {
      color: var(--text-secondary);
      text-align: center;
      padding: 18px 0;
    }

    .sitrep-actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      margin-top: 12px;
    }

    .sitrep-btn {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      color: var(--text-primary);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: border-color 0.15s ease, color 0.15s ease;
    }

    .sitrep-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .sitrep-btn.danger {
      border-color: rgba(239, 68, 68, 0.5);
      color: #ef4444;
    }

    .sitrep-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .heartbeat {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .heartbeat-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--text-secondary);
      box-shadow: none;
    }

    .heartbeat-dot.active {
      background: var(--accent);
      box-shadow: 0 0 18px var(--accent-dim);
      animation: heartbeatPulse 1.6s ease-in-out infinite;
    }

    @keyframes heartbeatPulse {
      0% { transform: scale(0.9); opacity: 0.65; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(0.9); opacity: 0.65; }
    }

    /* Responsive */
    @media (max-width: 700px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .hit-list {
        min-height: 240px;
        max-height: 240px;
      }

      .sitrep-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .sitrep-summary {
        justify-items: start;
        width: 100%;
      }

      .last-hit-group {
        flex-direction: column;
        align-items: stretch;
      }

      .last-hit-btn {
        width: 100%;
        min-width: 0;
      }

      .loop-controls {
        grid-template-columns: 1fr;
      }

      .widget-header.with-actions {
        flex-wrap: wrap;
      }

      .widget-header.with-actions .widget-header-actions {
        width: 100%;
        justify-content: flex-end;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <div class="header-left">
      <button class="logo" id="logo-toggle" type="button" aria-pressed="false" title="Open situation report">
        SB3
      </button>
    </div>
    <div class="last-hit-group">
      <button class="last-hit-btn" id="last-hit-airband" type="button">
        <span class="label">Airband</span>
        <span class="value" id="last-hit-airband-value">--</span>
      </button>
      <button class="last-hit-btn" id="last-hit-ground" type="button">
        <span class="label">Ground</span>
        <span class="value" id="last-hit-ground-value">--</span>
      </button>
      <button class="last-hit-btn" id="last-hit-digital" type="button">
        <span class="label">Digital</span>
        <span class="value" id="last-hit-digital-value">--</span>
      </button>
    </div>
    <div class="header-right">
      <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()" title="Toggle red theme">üî¥</button>
    </div>
  </div>

  <div class="view-stack">
    <!-- Main Content -->
    <div class="main view view-main">
      <div class="grid">

      <!-- Row 1: Controls + Profiles -->
      <div class="widget">
        <div class="widget-header">
          <span>‚öôÔ∏è Radio Controls</span>
          <div class="tabs">
            <button class="tab active" id="tab-airband" onclick="switchTarget('airband')">Airband</button>
            <button class="tab" id="tab-ground" onclick="switchTarget('ground')">Ground</button>
            <button class="tab" id="tab-digital" onclick="switchTarget('digital')">Digital</button>
          </div>
        </div>
        <div class="widget-body">
          <div id="controls-analog">
            <div class="control-group">
            <div class="control-item">
              <div class="control-label">
                <span>Gain (dB)</span>
                <span class="control-value" id="gain-value">--</span>
              </div>
              <input type="range" class="slider" id="gain-slider" min="0" max="28" step="1" value="14">
              <div class="control-applied">Applied: <span id="gain-applied">--</span></div>
            </div>

            <div class="control-item" id="dbfs-control">
              <div class="control-label">
                <span>Squelch (dBFS)</span>
                <span class="control-value" id="dbfs-value">--</span>
              </div>
              <input type="range" class="slider" id="dbfs-slider" min="-120" max="0" step="1" value="-70">
              <div class="control-applied" style="opacity:0.75;">Tightest = -1 (0 is treated as open)</div>
              <div class="control-applied">Applied: <span id="dbfs-applied">--</span></div>
            </div>

            <div class="control-item">
              <div class="control-label">
                <span>Filter (Hz)</span>
                <span class="control-value" id="filter-value">--</span>
              </div>
              <input type="range" class="slider" id="filter-slider" min="2000" max="5000" step="100" value="3500">
              <div class="control-applied">Applied: <span id="filter-applied">--</span></div>
            </div>
            </div>

            <div class="btn-row">
              <button class="action" id="btn-play-analog">Play</button>
              <button class="action" id="btn-tune">Tune</button>
              <button class="action" id="btn-avoid">Avoid</button>
              <button class="action" id="btn-clear-avoids">Clear</button>
              <button class="action" id="btn-apply">Apply</button>
            </div>

            <div class="player-box" id="player-box-analog">
              <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:6px;">
                <div style="font-weight:700;">Analog Player</div>
                <a id="lnk-stream-analog" href="#" target="_blank" rel="noopener" style="font-size:12px; opacity:0.85;">Open Analog</a>
              </div>
              <audio id="audio-player-analog" controls preload="none"></audio>
            </div>
          </div>

          <div id="controls-digital" class="hidden">
            <div class="control-group">
              <div class="control-item">
                <div class="control-label">
                  <span>Status</span>
                  <span class="control-value digital-status">
                    <span class="digital-dot" id="digital-dot"></span>
                    <span id="digital-status">--</span>
                  </span>
                </div>
                <div class="control-applied">Backend: <span id="digital-backend">--</span></div>
                <div class="control-applied">Profile: <span id="digital-profile">--</span></div>
                <div class="control-applied">Control Channel: <span class="config-value" id="digital-cc-status">--</span></div>
                <div class="control-applied"><span id="digital-cc-detail">--</span></div>
                <div class="control-applied">Systems: <span class="config-value" id="digital-system-health">--</span></div>
                <div class="control-applied"><span id="digital-system-health-detail">--</span></div>
                <div class="control-applied">RTL Dongles: <span class="config-value" id="digital-dongle-health">--</span></div>
                <div class="control-applied">Missing: <span class="config-value" id="digital-dongle-missing">--</span></div>
              </div>

              <div class="control-item">
                <div class="control-label">
                  <span>Last Activity</span>
                  <span class="control-value" id="digital-last-time">--</span>
                </div>
                <div class="control-applied"><span id="digital-last-label">--</span></div>
                <div class="control-applied" id="digital-last-mode"></div>
              </div>

              <div class="btn-row">
                <button class="action" id="btn-play-digital">Play</button>
                <button class="action" id="digital-stop">Stop</button>
                <button class="action" id="digital-restart">Restart</button>
              </div>

              <div class="player-box" id="player-box-digital">
                <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:6px;">
                  <div style="font-weight:700;">Digital Player</div>
                  <a id="lnk-stream-digital" href="#" target="_blank" rel="noopener" style="font-size:12px; opacity:0.85;">Open Digital</a>
                </div>
                <audio id="audio-player-digital" controls preload="none"></audio>
              </div>

            </div>
          </div>

        </div>
      </div>

      <div class="widget" id="profiles-widget">
        <div class="widget-header with-actions">
          <span>üéØ Profiles</span>
          <div class="widget-header-actions">
            <span class="loop-indicator" id="profiles-loop-indicator" title="Loop status">Loop Off</span>
            <button class="action widget-header-action sidecar-toggle" id="profile-loop-open-analog" type="button">Profile Loop</button>
            <button class="action widget-header-action sidecar-toggle" id="profile-editor-open-analog" type="button">Profile Editor</button>
          </div>
        </div>
        <div class="widget-body">
          <div class="profiles-grid" id="profiles-list">
            <div class="empty-state">
              <div class="icon">üì°</div>
              <div>Loading profiles...</div>
            </div>
          </div>
        </div>
      </div>

      <div class="widget hidden" id="digital-profiles-widget">
        <div class="widget-header with-actions">
          <span>üéõÔ∏è Digital Profiles</span>
          <div class="widget-header-actions">
            <span class="loop-indicator" id="digital-profiles-loop-indicator" title="Loop status">Loop Off</span>
            <button class="action widget-header-action sidecar-toggle" id="profile-loop-open-digital" type="button">Profile Loop</button>
            <button class="action widget-header-action sidecar-toggle" id="profile-editor-open-digital" type="button">Profile Editor</button>
          </div>
        </div>
        <div class="widget-body">
          <div class="profiles-grid" id="digital-profiles-list">
            <div class="empty-state">
              <div class="icon">üì°</div>
              <div>No digital profiles yet</div>
            </div>
          </div>
          <div class="control-group" style="margin-top:12px;">
            <div class="control-item">
              <div class="control-label">
                <span>Active Profile</span>
                <span class="control-value" id="digital-profile-status"></span>
              </div>
              <div class="control-applied" id="digital-error"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Row 2: Hit Counters + Hit List -->
      <div class="widget">
        <div class="widget-header">üìä System Activity</div>
        <div class="widget-body">
          <div class="counter-grid">
            <div class="counter-item">
              <div class="counter-label">Hits/Hour</div>
              <div class="counter-value" id="hit-count">--</div>
              <div class="counter-rate" id="hit-rate"></div>
            </div>
            <div class="counter-item">
              <div class="counter-label">Session</div>
              <div class="counter-value" id="session-count">0</div>
              <div class="counter-rate" id="session-start">--</div>
            </div>
            <div class="counter-item">
              <div class="counter-label">Avoids</div>
              <div class="counter-value" id="avoids-count">--</div>
              <div class="counter-rate" id="avoids-target"></div>
            </div>
            <div class="counter-item">
              <div class="counter-label">Local Time</div>
              <div class="counter-value" id="pi-time">--</div>
            </div>
          </div>
          <div class="control-item" style="margin-top:14px;">
            <div class="control-label">
              <span>Pi Health</span>
            </div>
            <div class="system-grid">
              <div class="system-item">
                <div class="label">CPU Temp</div>
                <div class="value" id="sys-cpu-temp">--</div>
              </div>
              <div class="system-item">
                <div class="label">GPU Temp</div>
                <div class="value" id="sys-gpu-temp">--</div>
              </div>
              <div class="system-item">
                <div class="label">CPU Usage</div>
                <div class="value" id="sys-cpu-usage">--</div>
              </div>
              <div class="system-item">
                <div class="label">Uptime</div>
                <div class="value" id="sys-uptime-tile">--</div>
              </div>
              <div class="system-item">
                <div class="label">Network RX</div>
                <div class="value" id="sys-net-rx">--</div>
                <div class="sub" id="sys-net-rx-rate">--</div>
              </div>
              <div class="system-item">
                <div class="label">Network TX</div>
                <div class="value" id="sys-net-tx">--</div>
                <div class="sub" id="sys-net-tx-rate">--</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="widget">
        <div class="widget-header">üìã Recent Hits</div>
        <div class="widget-body">
          <div class="hit-list" id="hit-list">
            <div class="hit-row header">
              <div>Time</div>
              <div>Frequency</div>
              <div>Dur</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Row 3: ADS-B (full width) -->
      <div class="widget grid-full">
        <div class="widget-header">
          ‚úàÔ∏è ADS-B Traffic
        </div>
        <div class="widget-body" id="adsb-body" style="padding: 0;">
          <iframe src="https://adsb.lol" class="adsb-frame" id="adsb-frame" allow="geolocation"></iframe>
        </div>
      </div>

      </div>
    </div>

    <!-- Sitrep -->
    <div class="sitrep view view-sitrep hidden" aria-live="polite">
      <div class="sitrep-header">
        <div>
          <div class="sitrep-eyebrow">Situation Report</div>
          <div class="sitrep-headline">SB3 Operations Console</div>
          <div class="sitrep-meta">Updated <span id="sitrep-updated">--</span> | Session <span id="sitrep-session">--</span></div>
        </div>
        <div class="sitrep-summary">
          <div class="sitrep-chip" id="sitrep-connection">Core link --</div>
          <div class="sitrep-chip" id="sitrep-stream">Audio stream --</div>
          <div class="sitrep-chip" id="sitrep-config">Config sync --</div>
        </div>
      </div>

      <div class="sitrep-grid">
        <div class="sitrep-card">
          <div class="sitrep-card-title">Operational Metrics</div>
          <div class="metric-grid">
            <div class="metric-item">
              <div class="metric-label">Hit Rate/hr</div>
              <div class="metric-value" id="sitrep-hit-rate">--</div>
              <div class="metric-sub">Session hits: <span id="sitrep-session-hits">0</span></div>
            </div>
            <div class="metric-item">
              <div class="metric-label">Last Hit</div>
              <div class="metric-value" id="sitrep-last-hit">--</div>
              <div class="metric-sub">Airband: <span id="sitrep-last-airband">--</span></div>
            </div>
            <div class="metric-item">
              <div class="metric-label">Active Target</div>
              <div class="metric-value" id="sitrep-active-target">--</div>
              <div class="metric-sub">Mode: <span id="sitrep-tune">--</span></div>
            </div>
            <div class="metric-item">
              <div class="metric-label">Hold Status</div>
              <div class="metric-value" id="sitrep-hold">--</div>
              <div class="metric-sub">Ground: <span id="sitrep-last-ground">--</span></div>
            </div>
          </div>
        </div>

        <div class="sitrep-card">
          <div class="sitrep-card-title">Service + Microservice Health</div>
          <div class="service-list">
            <div class="service-item" data-service="api">
              <div>
                <div class="service-name">API Core</div>
                <div class="service-meta">Status: <span id="service-api">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="sse">
              <div>
                <div class="service-name">SSE Stream</div>
                <div class="service-meta">Status: <span id="service-sse">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="airband">
              <div>
                <div class="service-name">Combined Scanner</div>
                <div class="service-meta">Status: <span id="service-airband">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="ground">
              <div>
                <div class="service-name">Ground Unit</div>
                <div class="service-meta">Status: <span id="service-ground">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="digital">
              <div>
                <div class="service-name">Digital Decoder</div>
                <div class="service-meta">Status: <span id="service-digital">--</span></div>
                <div class="service-meta" id="service-digital-note"></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="icecast">
              <div>
                <div class="service-name">Icecast Audio</div>
                <div class="service-meta">Status: <span id="service-icecast">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="vlc">
              <div>
                <div class="service-name">VLC Playback</div>
                <div class="service-meta">Status: <span id="service-vlc">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
            <div class="service-item" data-service="adsb">
              <div>
                <div class="service-name">ADS-B Panel</div>
                <div class="service-meta">Status: <span id="service-adsb">--</span></div>
              </div>
              <span class="service-dot"></span>
            </div>
          </div>
          <div class="sitrep-actions">
            <button class="sitrep-btn" id="btn-restart-airband" type="button">Restart Airband</button>
            <button class="sitrep-btn" id="btn-restart-ground" type="button">Restart Ground</button>
            <button class="sitrep-btn" id="btn-restart-digital" type="button">Restart Digital</button>
            <button class="sitrep-btn" id="btn-restart-icecast" type="button">Restart Icecast</button>
            <button class="sitrep-btn" id="btn-restart-keepalive" type="button">Restart Keepalive</button>
            <button class="sitrep-btn danger" id="btn-restart-ui" type="button">Restart UI</button>
          </div>
        </div>

        <div class="sitrep-card">
          <div class="sitrep-card-title">System Telemetry</div>
          <div class="config-grid">
            <div class="config-row">
              <span class="config-label">CPU Temp</span>
              <span class="config-value" id="sitrep-cpu-temp">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">GPU Temp</span>
              <span class="config-value" id="sitrep-gpu-temp">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">CPU Usage</span>
              <span class="config-value" id="sitrep-cpu-usage">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Uptime</span>
              <span class="config-value" id="sitrep-uptime">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Net RX</span>
              <span class="config-value" id="sitrep-net-rx">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Net TX</span>
              <span class="config-value" id="sitrep-net-tx">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">RX Rate</span>
              <span class="config-value" id="sitrep-net-rx-rate">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">TX Rate</span>
              <span class="config-value" id="sitrep-net-tx-rate">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">RTL Dongles</span>
              <span class="config-value" id="sitrep-dongles">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Missing</span>
              <span class="config-value" id="sitrep-dongles-missing">--</span>
            </div>
          </div>
        </div>

        <div class="sitrep-card">
          <div class="sitrep-card-title">Signal Pipeline</div>
          <div class="config-grid">
            <div class="config-row">
              <span class="config-label">Airband Gain</span>
              <span class="config-value" id="sitrep-gain-airband">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Ground Gain</span>
              <span class="config-value" id="sitrep-gain-ground">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Airband Squelch</span>
              <span class="config-value" id="sitrep-squelch-airband">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Ground Squelch</span>
              <span class="config-value" id="sitrep-squelch-ground">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Airband Filter</span>
              <span class="config-value" id="sitrep-filter-airband">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Ground Filter</span>
              <span class="config-value" id="sitrep-filter-ground">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Audio Mounts</span>
              <span class="config-value" id="sitrep-mounts">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Airband Heartbeat</span>
              <span class="config-value heartbeat">
                <span class="heartbeat-dot" id="sitrep-airband-dot"></span>
                <span id="sitrep-airband-heartbeat">--</span>
              </span>
            </div>
            <div class="config-row">
              <span class="config-label">Ground Heartbeat</span>
              <span class="config-value heartbeat">
                <span class="heartbeat-dot" id="sitrep-ground-dot"></span>
                <span id="sitrep-ground-heartbeat">--</span>
              </span>
            </div>
          </div>
        </div>

        <div class="sitrep-card">
          <div class="sitrep-card-title">Profiles + Routing</div>
          <div class="config-grid">
            <div class="config-row">
              <span class="config-label">Airband Profile</span>
              <span class="config-value" id="sitrep-airband-profile">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Ground Profile</span>
              <span class="config-value" id="sitrep-ground-profile">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Avoids Loaded</span>
              <span class="config-value" id="sitrep-avoids">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Tune Mode</span>
              <span class="config-value" id="sitrep-tune-mode">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Digital Profile</span>
              <span class="config-value" id="sitrep-digital-profile">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Digital Mode</span>
              <span class="config-value" id="sitrep-digital-mode">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Active System</span>
              <span class="config-value" id="sitrep-digital-active-system">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Next System</span>
              <span class="config-value" id="sitrep-digital-next-system">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Switch Reason</span>
              <span class="config-value" id="sitrep-digital-switch">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Control Channel</span>
              <span class="config-value" id="sitrep-digital-cc">--</span>
            </div>
            <div class="config-row">
              <span class="config-label">Systems Health</span>
              <span class="config-value" id="sitrep-digital-systems">--</span>
            </div>
          </div>
        </div>

        <div class="sitrep-card grid-full">
          <div class="sitrep-card-title">Live Activity Log</div>
          <div class="activity-log" id="activity-log">
            <div class="log-empty">Waiting for events...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="profile-sidecar-overlay hidden" id="profile-sidecar-overlay"></div>
  <aside class="profile-sidecar" id="profile-sidecar" aria-hidden="true">
    <div class="profile-sidecar-header">
      <div>
        <div class="profile-sidecar-title">Profile Editor Sidecar</div>
        <div class="profile-sidecar-sub">Edit analog and digital profile data in one place</div>
      </div>
      <button class="action" id="profile-sidecar-close" type="button">Close</button>
    </div>
    <div class="profile-sidecar-tabs">
      <div class="profile-sidecar-tab-group">
        <button class="profile-sidecar-tab active" id="profile-editor-tab-analog" type="button">Analog</button>
        <button class="profile-sidecar-tab" id="profile-editor-tab-digital" type="button">Digital</button>
      </div>
      <div class="profile-sidecar-actions">
        <button class="action profile-sidecar-load" id="profile-editor-new-active" type="button">New</button>
        <button class="action profile-sidecar-load" id="profile-editor-load-active" type="button">Load</button>
      </div>
    </div>
    <div class="profile-sidecar-body">
      <section class="profile-sidecar-panel" id="profile-editor-panel-analog">
        <div class="profile-editor-card">
          <div class="control-label">
            <span>Analog Profile</span>
            <span class="control-value">freq + hit text + modulation</span>
          </div>
          <div class="profile-editor-grid">
            <label>
              Target
              <select id="profile-editor-analog-target">
                <option value="airband">Airband</option>
                <option value="ground">Ground</option>
              </select>
            </label>
            <label>
              Profile
              <select id="profile-editor-analog-profile"></select>
            </label>
          </div>
          <div class="profile-editor-grid">
            <label>
              Modulation
              <input id="profile-editor-analog-modulation" type="text" value="am" spellcheck="false">
            </label>
            <label>
              Bandwidth (Hz)
              <input id="profile-editor-analog-bandwidth" type="number" min="2000" max="250000" step="100" value="12000">
            </label>
          </div>
          <label>
            Frequencies (one per line: <code>118.600 TOWER</code>)
            <textarea id="profile-editor-analog-freqs" rows="10" spellcheck="false"></textarea>
          </label>
          <div class="profile-editor-actions">
            <button class="action" id="profile-editor-analog-validate" type="button">Validate</button>
            <button class="action" id="profile-editor-analog-save" type="button">Save</button>
            <button class="action" id="profile-editor-analog-delete" type="button">Delete</button>
            <span class="profile-editor-pill hidden" id="profile-editor-analog-dirty">Unsaved</span>
          </div>
          <div class="profile-editor-status" id="profile-editor-analog-status"></div>
        </div>
      </section>

      <section class="profile-sidecar-panel hidden" id="profile-editor-panel-digital">
        <div class="profile-editor-card">
          <div class="control-label">
            <span>Digital Profile</span>
            <span class="control-value">control channels + TG metadata</span>
          </div>
          <div class="profile-editor-grid">
            <label>
              Profile
              <select id="profile-editor-digital-profile"></select>
            </label>
            <div></div>
          </div>
          <label>
            Control Channels (MHz, one per line)
            <textarea id="profile-editor-digital-controls" rows="4" spellcheck="false"></textarea>
          </label>
          <label>
            Systems JSON (optional explicit per-system definitions)
            <textarea id="profile-editor-digital-systems" rows="8" spellcheck="false"></textarea>
          </label>
          <div class="control-applied" style="opacity:0.75;">
            Format: <code>{"systems":[{"name":"TACN D3","control_channels_mhz":[769.83125]}]}</code>
          </div>
          <label>
            Talkgroups CSV
            <textarea id="profile-editor-digital-talkgroups" rows="16" spellcheck="false"></textarea>
          </label>
          <div class="control-applied" style="opacity:0.75;">
            Expected columns: <code>DEC,MODE,ALPHA,DESCRIPTION,TAG,LISTEN</code>
          </div>
          <div class="digital-listen" id="digital-listen">
            <div class="control-label" style="margin-bottom:8px;">
              <span>Talkgroup Listen</span>
              <span class="control-value" id="digital-listen-status"></span>
            </div>
            <div class="digital-listen-toolbar">
              <input id="digital-listen-search" type="text" placeholder="Search TGID, mode, tag">
              <select id="digital-listen-filter">
                <option value="all">All</option>
                <option value="listen">Listening</option>
                <option value="muted">Muted</option>
              </select>
              <select id="digital-listen-mode-filter">
                <option value="all">All Modes</option>
                <option value="clear">Clear</option>
                <option value="encrypted">Encrypted</option>
                <option value="D">D</option>
                <option value="T">T</option>
                <option value="DE">DE</option>
                <option value="TE">TE</option>
              </select>
              <button class="action" id="digital-listen-mute-encrypted">Mute Encrypted</button>
              <button class="action" id="digital-listen-load">Load</button>
              <button class="action" id="digital-listen-enable-filtered">Select Filtered</button>
              <button class="action" id="digital-listen-disable-filtered">Unselect Filtered</button>
              <button class="action" id="digital-listen-save">Save</button>
              <button class="action" id="digital-listen-toggle">Hide</button>
            </div>
            <div class="digital-listen-body">
              <div class="digital-listen-list" id="digital-listen-list"></div>
              <div class="control-applied" style="opacity:0.75;">
                Listen flags only affect SB3 hit display for now (SDRTrunk still scans everything).
              </div>
            </div>
          </div>
          <div class="profile-editor-actions">
            <button class="action" id="profile-editor-digital-validate" type="button">Validate</button>
            <button class="action" id="profile-editor-digital-save" type="button">Save</button>
            <button class="action" id="profile-editor-digital-delete" type="button">Delete</button>
            <span class="profile-editor-pill hidden" id="profile-editor-digital-dirty">Unsaved</span>
          </div>
          <div class="profile-editor-status" id="profile-editor-digital-status"></div>
        </div>
      </section>
    </div>
  </aside>

  <div class="profile-sidecar-overlay hidden" id="profile-loop-sidecar-overlay"></div>
  <aside class="profile-sidecar" id="profile-loop-sidecar" aria-hidden="true">
    <div class="profile-sidecar-header">
      <div>
        <div class="profile-sidecar-title">Profile Loop Sidecar</div>
        <div class="profile-sidecar-sub">Rotate profiles with dwell/hang timing and hit hold</div>
      </div>
      <button class="action" id="profile-loop-sidecar-close" type="button">Close</button>
    </div>
    <div class="profile-sidecar-tabs">
      <div class="profile-sidecar-tab-group">
        <button class="profile-sidecar-tab active" id="profile-loop-tab-analog" type="button">Analog</button>
        <button class="profile-sidecar-tab" id="profile-loop-tab-digital" type="button">Digital</button>
      </div>
      <div class="profile-sidecar-actions">
        <button class="action profile-sidecar-load" id="profile-loop-refresh" type="button">Refresh</button>
      </div>
    </div>
    <div class="profile-sidecar-body">
      <section class="profile-sidecar-panel" id="profile-loop-panel-analog">
        <div class="profile-loop-panel">
          <div class="control-label">
            <span>Profile Loop</span>
            <span class="control-value" id="loop-status">--</span>
          </div>
          <div class="control-applied" id="loop-detail">--</div>
          <div class="loop-checklist" id="loop-list"></div>
          <div class="loop-controls">
            <label>Dwell (s)
              <input id="loop-dwell" type="number" min="1" max="1800" step="1" value="45">
            </label>
            <label>Hang (s)
              <input id="loop-hang" type="number" min="1" max="600" step="1" value="12">
            </label>
            <label class="loop-checkbox-label">
              <input id="loop-pause" type="checkbox" checked>
              Pause On Hit
            </label>
          </div>
          <div class="btn-row">
            <button class="action" id="loop-save" type="button">Apply Loop</button>
            <button class="action" id="loop-toggle" type="button">Start Loop</button>
            <button class="action" id="loop-select-all" type="button">All</button>
            <button class="action" id="loop-clear" type="button">None</button>
          </div>
        </div>
      </section>

      <section class="profile-sidecar-panel hidden" id="profile-loop-panel-digital">
        <div class="profile-loop-panel">
          <div class="control-label">
            <span>Digital Profile Loop</span>
            <span class="control-value" id="digital-loop-status">--</span>
          </div>
          <div class="control-applied" id="digital-loop-detail">--</div>
          <div class="loop-checklist" id="digital-loop-list"></div>
          <div class="loop-controls">
            <label>Dwell (s)
              <input id="digital-loop-dwell" type="number" min="1" max="1800" step="1" value="30">
            </label>
            <label>Hang (s)
              <input id="digital-loop-hang" type="number" min="1" max="600" step="1" value="8">
            </label>
            <label class="loop-checkbox-label">
              <input id="digital-loop-pause" type="checkbox" checked>
              Pause On Hit
            </label>
          </div>
          <div class="btn-row">
            <button class="action" id="digital-loop-save" type="button">Apply Loop</button>
            <button class="action" id="digital-loop-toggle" type="button">Start Loop</button>
            <button class="action" id="digital-loop-select-all" type="button">All</button>
            <button class="action" id="digital-loop-clear" type="button">None</button>
          </div>
        </div>
      </section>
    </div>
  </aside>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    
    const GAIN_STEPS = [
      0.0, 0.9, 1.4, 2.7, 3.7, 7.7, 8.7, 12.5, 14.4, 15.7,
      16.6, 19.7, 20.7, 22.9, 25.4, 28.0, 29.7, 32.8, 33.8,
      36.4, 37.2, 38.6, 40.2, 42.1, 43.4, 43.9, 44.5, 48.0, 49.6,
    ];
    const DEBOUNCE_MS = 500;
    const VIEW_FLIP_MS = 480;
    const MAX_LOG = 120;
    const LOG_DEDUPE_MS = 4000;
    const AUDIO_RECOVER_COOLDOWN_MS = 8000;
    const AUDIO_WAITING_GRACE_MS = 12000;
    const AUDIO_PROGRESS_CHECK_MS = 3000;
    const AUDIO_PROGRESS_STALL_MS = 30000;
    const FETCH_TIMEOUT_MS = 8000;
    
    // ============================================
    // STATE
    // ============================================
    
    let activeTarget = 'airband';
    let activeView = 'airband';
    const audioRecoverState = new WeakMap();

    function defaultProfileLoopState() {
      return {
        enabled: false,
        selectedProfiles: [],
        availableProfiles: [],
        currentProfile: '',
        activeProfile: '',
        nextProfile: '',
        dwellMs: 45000,
        hangMs: 12000,
        pauseOnHit: true,
        recentHit: false,
        inHitHold: false,
        blockedReason: '',
        switchReason: '',
        lastError: '',
        lastSwitchTimeMs: 0,
      };
    }
    
    let state = {
      connected: false,
      sdr1Active: false,
      sdr2Active: false,
      icecastActive: false,
      icecastMounts: [],
      icecastExpectedMounts: [],
      icecastPort: 8000,
      streamMount: 'ANALOG.mp3',
      digitalStreamMount: 'DIGITAL.mp3',
      streamProxyEnabled: true,
      streamBaseUrl: '',
      digitalStreamBaseUrl: '',
      sseConnected: false,
      adsbLoaded: false,
      combinedStale: false,
      rtlRestartRequired: false,
      groundUnitActive: false,
      lastStatusTick: null,
      sdr1LastSeen: null,
      sdr2LastSeen: null,
      eventSource: null,
      lastHit: '',
      lastHitAirband: '',
      lastHitGround: '',
      lastHitAirbandLabel: '',
      lastHitGroundLabel: '',
      lastHitDigital: '',
      hits: [],
      hold: { airband: null, ground: null, digital: null },
      lastProfile: { airband: '', ground: '' },
      tuned: false,
      tunedFreq: null,
      tunedTarget: null,
      sessionHits: 0,
      sessionStart: Date.now(),
      applyTimeout: null,
      filterTimeout: null,
      streamRecoveryTimers: { analog: [], digital: [] },
      serverTime: null,
      systemStats: null,
      v3Compile: null,
      preflight: {
        airband: null,
        ground: null,
        digital: null,
      },
      health: {
        overall: { state: 'unknown', reasonCodes: [] },
        subsystems: {},
      },
      system: {
        lastNetTs: 0,
        lastRx: 0,
        lastTx: 0,
        lastRxRate: null,
        lastTxRate: null,
      },
      vlc: {
        analog: { running: false, busy: false },
        digital: { running: false, busy: false },
      },
      airband: {
        gain: 32.8,
        squelch: 0.5,
        squelch_mode: 'dbfs',
        squelch_snr: 0.5,
        squelch_dbfs: 0,
        applied_gain: null,
        applied_squelch_dbfs: null,
        filter: 3500,
        profiles: [],
        currentProfile: '',
        avoids: [],
      },
      ground: {
        gain: 32.8,
        squelch: 0.5,
        squelch_mode: 'dbfs',
        squelch_snr: 0.5,
        squelch_dbfs: 0,
        applied_gain: null,
        applied_squelch_dbfs: null,
        filter: 3500,
        profiles: [],
        currentProfile: '',
        avoids: [],
      },
      digital: {
        active: false,
        backend: '',
        profile: '',
        lastLabel: '',
        lastMode: '',
        lastTime: 0,
        lastError: '',
        lastWarning: '',
        playlistSourceOk: false,
        playlistSourceType: '',
        playlistSourceError: '',
        tunerBusyCount: 0,
        controlMetricReady: false,
        controlLocked: false,
        controlCount: 0,
        controlLastTime: 0,
        controlSyncLossCount: 0,
        controlWindowMs: 0,
        schedulerMode: '',
        schedulerActiveSystem: '',
        schedulerNextSystem: '',
        schedulerSwitchReason: '',
        schedulerLastSwitchTime: 0,
        schedulerLastApplyError: '',
        schedulerLockTimeoutMs: 0,
        schedulerSystemHealth: [],
        schedulerRaw: null,
        preflightRaw: null,
        muted: false,
        profiles: [],
        activeProfile: '',
      },
      digitalListen: {
        items: [],
        search: '',
        filter: 'all',
        modeFilter: 'all',
        sortKey: 'dec',
        sortDir: 'asc',
        dirty: false,
        profile: '',
      },
      profileLoop: {
        airband: defaultProfileLoopState(),
        ground: defaultProfileLoopState(),
        digital: { ...defaultProfileLoopState(), dwellMs: 30000, hangMs: 8000 },
      },
      profileLoopUi: {
        open: false,
        tab: 'analog',
        draftSelected: {
          airband: null,
          ground: null,
          digital: null,
        },
        applyTimers: {
          airband: null,
          ground: null,
          digital: null,
        },
      },
      profileEditor: {
        open: false,
        tab: 'analog',
        analog: {
          target: 'airband',
          profileId: '',
          dirty: false,
        },
        digital: {
          profileId: '',
          dirty: false,
        },
      },
    };

    let digitalProfilesLoaded = false;
    let digitalListenLoaded = false;
    let refreshInFlight = null;
    let refreshHitsInFlight = null;
    
    // ============================================
    // ELEMENTS
    // ============================================
    
    const els = {
      lastHitAirband: document.getElementById('last-hit-airband'),
      lastHitGround: document.getElementById('last-hit-ground'),
      lastHitDigital: document.getElementById('last-hit-digital'),
      lastHitAirbandValue: document.getElementById('last-hit-airband-value'),
      lastHitGroundValue: document.getElementById('last-hit-ground-value'),
      lastHitDigitalValue: document.getElementById('last-hit-digital-value'),
      gainSlider: document.getElementById('gain-slider'),
      gainValue: document.getElementById('gain-value'),
      gainApplied: document.getElementById('gain-applied'),
      dbfsControl: document.getElementById('dbfs-control'),
      dbfsSlider: document.getElementById('dbfs-slider'),
      dbfsValue: document.getElementById('dbfs-value'),
      dbfsApplied: document.getElementById('dbfs-applied'),
      filterSlider: document.getElementById('filter-slider'),
      filterValue: document.getElementById('filter-value'),
      filterApplied: document.getElementById('filter-applied'),
      btnPlayAnalog: document.getElementById('btn-play-analog'),
      btnPlayDigital: document.getElementById('btn-play-digital'),
      btnApply: document.getElementById('btn-apply'),
      profilesList: document.getElementById('profiles-list'),
      profilesWidget: document.getElementById('profiles-widget'),
      loopStatus: document.getElementById('loop-status'),
      loopDetail: document.getElementById('loop-detail'),
      loopList: document.getElementById('loop-list'),
      loopDwell: document.getElementById('loop-dwell'),
      loopHang: document.getElementById('loop-hang'),
      loopPause: document.getElementById('loop-pause'),
      loopSave: document.getElementById('loop-save'),
      loopToggle: document.getElementById('loop-toggle'),
      loopSelectAll: document.getElementById('loop-select-all'),
      loopClear: document.getElementById('loop-clear'),
      profilesLoopIndicator: document.getElementById('profiles-loop-indicator'),
      digitalProfilesWidget: document.getElementById('digital-profiles-widget'),
      digitalProfilesList: document.getElementById('digital-profiles-list'),
      digitalLoopStatus: document.getElementById('digital-loop-status'),
      digitalLoopDetail: document.getElementById('digital-loop-detail'),
      digitalLoopList: document.getElementById('digital-loop-list'),
      digitalLoopDwell: document.getElementById('digital-loop-dwell'),
      digitalLoopHang: document.getElementById('digital-loop-hang'),
      digitalLoopPause: document.getElementById('digital-loop-pause'),
      digitalLoopSave: document.getElementById('digital-loop-save'),
      digitalLoopToggle: document.getElementById('digital-loop-toggle'),
      digitalLoopSelectAll: document.getElementById('digital-loop-select-all'),
      digitalLoopClear: document.getElementById('digital-loop-clear'),
      digitalProfilesLoopIndicator: document.getElementById('digital-profiles-loop-indicator'),
      audioPlayerAnalog: document.getElementById('audio-player-analog'),
      audioPlayerDigital: document.getElementById('audio-player-digital'),
      lnkStreamAnalog: document.getElementById('lnk-stream-analog'),
      lnkStreamDigital: document.getElementById('lnk-stream-digital'),
      sysCpuTemp: document.getElementById('sys-cpu-temp'),
      sysGpuTemp: document.getElementById('sys-gpu-temp'),
      sysCpuUsage: document.getElementById('sys-cpu-usage'),
      sysUptimeTile: document.getElementById('sys-uptime-tile'),
      sysNetRx: document.getElementById('sys-net-rx'),
      sysNetTx: document.getElementById('sys-net-tx'),
      sysNetRxRate: document.getElementById('sys-net-rx-rate'),
      sysNetTxRate: document.getElementById('sys-net-tx-rate'),
      controlsAnalog: document.getElementById('controls-analog'),
      controlsDigital: document.getElementById('controls-digital'),
      digitalDot: document.getElementById('digital-dot'),
      digitalStatus: document.getElementById('digital-status'),
      digitalBackend: document.getElementById('digital-backend'),
      digitalProfile: document.getElementById('digital-profile'),
      digitalCcStatus: document.getElementById('digital-cc-status'),
      digitalCcDetail: document.getElementById('digital-cc-detail'),
      digitalSystemHealth: document.getElementById('digital-system-health'),
      digitalSystemHealthDetail: document.getElementById('digital-system-health-detail'),
      digitalDongleHealth: document.getElementById('digital-dongle-health'),
      digitalDongleMissing: document.getElementById('digital-dongle-missing'),
      digitalLastTime: document.getElementById('digital-last-time'),
      digitalLastLabel: document.getElementById('digital-last-label'),
      digitalLastMode: document.getElementById('digital-last-mode'),
      digitalProfileSelect: document.getElementById('digital-profile-select'),
      digitalProfileStatus: document.getElementById('digital-profile-status'),
      digitalError: document.getElementById('digital-error'),
      digitalManageId: document.getElementById('digital-manage-id'),
      digitalManageCreate: document.getElementById('digital-manage-create'),
      digitalManageDelete: document.getElementById('digital-manage-delete'),
      digitalManageStatus: document.getElementById('digital-manage-status'),
      digitalPreview: document.getElementById('digital-preview'),
      digitalPreviewText: document.getElementById('digital-preview-text'),
      digitalPreviewStatus: document.getElementById('digital-preview-status'),
      digitalPreviewLoad: document.getElementById('digital-preview-load'),
      digitalPreviewToggle: document.getElementById('digital-preview-toggle'),
      digitalListen: document.getElementById('digital-listen'),
      digitalListenList: document.getElementById('digital-listen-list'),
      digitalListenSearch: document.getElementById('digital-listen-search'),
      digitalListenFilter: document.getElementById('digital-listen-filter'),
      digitalListenModeFilter: document.getElementById('digital-listen-mode-filter'),
      digitalListenMuteEncrypted: document.getElementById('digital-listen-mute-encrypted'),
      digitalListenLoad: document.getElementById('digital-listen-load'),
      digitalListenEnableFiltered: document.getElementById('digital-listen-enable-filtered'),
      digitalListenDisableFiltered: document.getElementById('digital-listen-disable-filtered'),
      digitalListenSave: document.getElementById('digital-listen-save'),
      digitalListenToggle: document.getElementById('digital-listen-toggle'),
      digitalListenStatus: document.getElementById('digital-listen-status'),
      digitalStop: document.getElementById('digital-stop'),
      digitalRestart: document.getElementById('digital-restart'),
      manageTargetAirband: document.getElementById('manage-target-airband'),
      manageTargetGround: document.getElementById('manage-target-ground'),
      manageId: document.getElementById('manage-id'),
      manageLabel: document.getElementById('manage-label'),
      manageCreate: document.getElementById('manage-create'),
      manageRename: document.getElementById('manage-rename'),
      manageDelete: document.getElementById('manage-delete'),
      manageStatus: document.getElementById('manage-status'),
      freqEditProfile: document.getElementById('freq-edit-profile'),
      freqEditText: document.getElementById('freq-edit-text'),
      freqEditLoad: document.getElementById('freq-edit-load'),
      freqEditSave: document.getElementById('freq-edit-save'),
      freqEditToggle: document.getElementById('freq-edit-toggle'),
      freqEditor: document.getElementById('freq-editor'),
      freqEditStatus: document.getElementById('freq-edit-status'),
      hitList: document.getElementById('hit-list'),
      hitCount: document.getElementById('hit-count'),
      hitRate: document.getElementById('hit-rate'),
      sessionCount: document.getElementById('session-count'),
      sessionStart: document.getElementById('session-start'),
      avoidsCount: document.getElementById('avoids-count'),
      avoidsTarget: document.getElementById('avoids-target'),
      piTime: document.getElementById('pi-time'),
      tabAirband: document.getElementById('tab-airband'),
      tabGround: document.getElementById('tab-ground'),
      tabDigital: document.getElementById('tab-digital'),
      logoToggle: document.getElementById('logo-toggle'),
      viewMain: document.querySelector('.view-main'),
      viewSitrep: document.querySelector('.view-sitrep'),
      sitrepUpdated: document.getElementById('sitrep-updated'),
      sitrepSession: document.getElementById('sitrep-session'),
      sitrepHitRate: document.getElementById('sitrep-hit-rate'),
      sitrepSessionHits: document.getElementById('sitrep-session-hits'),
      sitrepLastHit: document.getElementById('sitrep-last-hit'),
      sitrepLastAirband: document.getElementById('sitrep-last-airband'),
      sitrepLastGround: document.getElementById('sitrep-last-ground'),
      sitrepActiveTarget: document.getElementById('sitrep-active-target'),
      sitrepTune: document.getElementById('sitrep-tune'),
      sitrepHold: document.getElementById('sitrep-hold'),
      sitrepAirbandProfile: document.getElementById('sitrep-airband-profile'),
      sitrepGroundProfile: document.getElementById('sitrep-ground-profile'),
      sitrepGainAirband: document.getElementById('sitrep-gain-airband'),
      sitrepGainGround: document.getElementById('sitrep-gain-ground'),
      sitrepSquelchAirband: document.getElementById('sitrep-squelch-airband'),
      sitrepSquelchGround: document.getElementById('sitrep-squelch-ground'),
      sitrepFilterAirband: document.getElementById('sitrep-filter-airband'),
      sitrepFilterGround: document.getElementById('sitrep-filter-ground'),
      sitrepMounts: document.getElementById('sitrep-mounts'),
      sitrepAirbandHeartbeat: document.getElementById('sitrep-airband-heartbeat'),
      sitrepGroundHeartbeat: document.getElementById('sitrep-ground-heartbeat'),
      sitrepAirbandDot: document.getElementById('sitrep-airband-dot'),
      sitrepGroundDot: document.getElementById('sitrep-ground-dot'),
      sitrepAvoids: document.getElementById('sitrep-avoids'),
      sitrepTuneMode: document.getElementById('sitrep-tune-mode'),
      sitrepDigitalProfile: document.getElementById('sitrep-digital-profile'),
      sitrepDigitalMode: document.getElementById('sitrep-digital-mode'),
      sitrepDigitalActiveSystem: document.getElementById('sitrep-digital-active-system'),
      sitrepDigitalNextSystem: document.getElementById('sitrep-digital-next-system'),
      sitrepDigitalSwitch: document.getElementById('sitrep-digital-switch'),
      sitrepDigitalCc: document.getElementById('sitrep-digital-cc'),
      sitrepDigitalSystems: document.getElementById('sitrep-digital-systems'),
      sitrepConnection: document.getElementById('sitrep-connection'),
      sitrepStream: document.getElementById('sitrep-stream'),
      sitrepConfig: document.getElementById('sitrep-config'),
      serviceDigitalNote: document.getElementById('service-digital-note'),
      sitrepCpuTemp: document.getElementById('sitrep-cpu-temp'),
      sitrepGpuTemp: document.getElementById('sitrep-gpu-temp'),
      sitrepCpuUsage: document.getElementById('sitrep-cpu-usage'),
      sitrepUptime: document.getElementById('sitrep-uptime'),
      sitrepNetRx: document.getElementById('sitrep-net-rx'),
      sitrepNetTx: document.getElementById('sitrep-net-tx'),
      sitrepNetRxRate: document.getElementById('sitrep-net-rx-rate'),
      sitrepNetTxRate: document.getElementById('sitrep-net-tx-rate'),
      sitrepDongles: document.getElementById('sitrep-dongles'),
      sitrepDonglesMissing: document.getElementById('sitrep-dongles-missing'),
      activityLog: document.getElementById('activity-log'),
      btnRestartAirband: document.getElementById('btn-restart-airband'),
      btnRestartGround: document.getElementById('btn-restart-ground'),
      btnRestartDigital: document.getElementById('btn-restart-digital'),
      btnRestartIcecast: document.getElementById('btn-restart-icecast'),
      btnRestartKeepalive: document.getElementById('btn-restart-keepalive'),
      btnRestartUi: document.getElementById('btn-restart-ui'),
      profileLoopOpenAnalog: document.getElementById('profile-loop-open-analog'),
      profileLoopOpenDigital: document.getElementById('profile-loop-open-digital'),
      profileLoopSidecar: document.getElementById('profile-loop-sidecar'),
      profileLoopSidecarOverlay: document.getElementById('profile-loop-sidecar-overlay'),
      profileLoopSidecarClose: document.getElementById('profile-loop-sidecar-close'),
      profileLoopTabAnalog: document.getElementById('profile-loop-tab-analog'),
      profileLoopTabDigital: document.getElementById('profile-loop-tab-digital'),
      profileLoopPanelAnalog: document.getElementById('profile-loop-panel-analog'),
      profileLoopPanelDigital: document.getElementById('profile-loop-panel-digital'),
      profileLoopRefresh: document.getElementById('profile-loop-refresh'),
      profileEditorOpenAnalog: document.getElementById('profile-editor-open-analog'),
      profileEditorOpenDigital: document.getElementById('profile-editor-open-digital'),
      profileSidecar: document.getElementById('profile-sidecar'),
      profileSidecarOverlay: document.getElementById('profile-sidecar-overlay'),
      profileSidecarClose: document.getElementById('profile-sidecar-close'),
      profileEditorTabAnalog: document.getElementById('profile-editor-tab-analog'),
      profileEditorTabDigital: document.getElementById('profile-editor-tab-digital'),
      profileEditorNewActive: document.getElementById('profile-editor-new-active'),
      profileEditorLoadActive: document.getElementById('profile-editor-load-active'),
      profileEditorPanelAnalog: document.getElementById('profile-editor-panel-analog'),
      profileEditorPanelDigital: document.getElementById('profile-editor-panel-digital'),
      profileEditorAnalogTarget: document.getElementById('profile-editor-analog-target'),
      profileEditorAnalogProfile: document.getElementById('profile-editor-analog-profile'),
      profileEditorAnalogModulation: document.getElementById('profile-editor-analog-modulation'),
      profileEditorAnalogBandwidth: document.getElementById('profile-editor-analog-bandwidth'),
      profileEditorAnalogFreqs: document.getElementById('profile-editor-analog-freqs'),
      profileEditorAnalogValidate: document.getElementById('profile-editor-analog-validate'),
      profileEditorAnalogSave: document.getElementById('profile-editor-analog-save'),
      profileEditorAnalogDelete: document.getElementById('profile-editor-analog-delete'),
      profileEditorAnalogDirty: document.getElementById('profile-editor-analog-dirty'),
      profileEditorAnalogStatus: document.getElementById('profile-editor-analog-status'),
      profileEditorDigitalProfile: document.getElementById('profile-editor-digital-profile'),
      profileEditorDigitalControls: document.getElementById('profile-editor-digital-controls'),
      profileEditorDigitalSystems: document.getElementById('profile-editor-digital-systems'),
      profileEditorDigitalTalkgroups: document.getElementById('profile-editor-digital-talkgroups'),
      profileEditorDigitalValidate: document.getElementById('profile-editor-digital-validate'),
      profileEditorDigitalSave: document.getElementById('profile-editor-digital-save'),
      profileEditorDigitalDelete: document.getElementById('profile-editor-digital-delete'),
      profileEditorDigitalDirty: document.getElementById('profile-editor-digital-dirty'),
      profileEditorDigitalStatus: document.getElementById('profile-editor-digital-status'),
      btnReconnect: null,
    };

    const activityLog = [];
    const logDedupe = new Map();
    const sessionHitKeys = new Set();
    let hitBaselineReady = false;
    let currentView = 'main';
    
    // ============================================
    // COLLAPSIBLE WIDGETS
    // ============================================
    
    function toggleWidget(widget, collapsedState) {
      if (!widget) return;
      const shouldCollapse = typeof collapsedState === 'boolean'
        ? collapsedState
        : !widget.classList.contains('collapsed');
      widget.classList.toggle('collapsed', shouldCollapse);
      const btn = widget.querySelector('.collapse-btn');
      if (btn) {
        btn.textContent = shouldCollapse ? '‚ñ∂' : '‚ñº';
      }
    }
    
    function setupCollapsibleWidgets() {
      document.querySelectorAll('.widget').forEach(widget => {
        const header = widget.querySelector('.widget-header');
        const body = widget.querySelector('.widget-body');
        if (!header || !body) return;
        
        header.addEventListener('click', (e) => {
          // Ignore clicks on interactive elements inside the header (e.g. tabs)
          if (e.target.closest('button, .tab, a, input, select, textarea')) {
            return;
          }
          toggleWidget(widget);
        });
      });
    }
    
    // ============================================
    // API
    // ============================================
    
    async function fetchWithTimeout(url, options = {}) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(timeoutId);
      }
    }

    async function fetchJSON(url) {
      const r = await fetchWithTimeout(url, { cache: 'no-store' });
      if (!r.ok) {
        let payload = null;
        try {
          payload = await r.json();
        } catch (_) {
          payload = null;
        }
        const msg = payload && payload.error
          ? `${payload.error} (HTTP ${r.status})`
          : `HTTP ${r.status} for ${url}`;
        const err = new Error(msg);
        err.payload = payload;
        err.status = r.status;
        throw err;
      }
      return r.json();
    }
    
    async function postAPI(endpoint, data) {
      const params = new URLSearchParams();
      Object.entries(data || {}).forEach(([k, v]) => {
        if (v === undefined || v === null) return;
        params.append(k, String(v));
      });
      const body = params.toString();
      const r = await fetchWithTimeout(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body
      });
      if (!r.ok) {
        let payload = null;
        try {
          payload = await r.json();
        } catch (_) {
          payload = null;
        }
        const msg = payload && payload.error
          ? `${payload.error} (HTTP ${r.status})`
          : `HTTP ${r.status} for ${endpoint}`;
        const err = new Error(msg);
        err.payload = payload;
        err.status = r.status;
        throw err;
      }
      return r.json();
    }

    async function postJSON(endpoint, payload) {
      const r = await fetchWithTimeout(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload || {}),
      });
      if (!r.ok) {
        let body = null;
        try {
          body = await r.json();
        } catch (_) {
          body = null;
        }
        const msg = body && body.error
          ? `${body.error} (HTTP ${r.status})`
          : `HTTP ${r.status} for ${endpoint}`;
        const err = new Error(msg);
        err.payload = body;
        err.status = r.status;
        throw err;
      }
      return r.json();
    }

    function setProfileEditorStatus(kind, message, isError = false) {
      const el = kind === 'digital' ? els.profileEditorDigitalStatus : els.profileEditorAnalogStatus;
      if (!el) return;
      el.textContent = message || '';
      el.style.color = isError ? '#f59e0b' : '';
    }

    function setProfileEditorDirty(kind, dirty = true) {
      const token = kind === 'digital' ? 'digital' : 'analog';
      if (!state.profileEditor || !state.profileEditor[token]) return;
      state.profileEditor[token].dirty = Boolean(dirty);
      const badge = token === 'digital' ? els.profileEditorDigitalDirty : els.profileEditorAnalogDirty;
      if (badge) {
        const show = token === 'digital'
          ? Boolean(state.profileEditor[token].dirty || (state.digitalListen && state.digitalListen.dirty))
          : Boolean(state.profileEditor[token].dirty);
        badge.classList.toggle('hidden', !show);
      }
    }

    function profileEditorHasUnsaved(kind) {
      const token = kind === 'digital' ? 'digital' : 'analog';
      if (token === 'digital') {
        return Boolean(
          (state.profileEditor?.digital?.dirty)
          || (state.digitalListen && state.digitalListen.dirty)
        );
      }
      return Boolean(state.profileEditor?.analog?.dirty);
    }

    function profileEditorAnyUnsaved() {
      return profileEditorHasUnsaved('analog') || profileEditorHasUnsaved('digital');
    }

    function profileEditorConfirmDiscard(kind, actionLabel) {
      if (!profileEditorHasUnsaved(kind)) return true;
      const area = kind === 'digital' ? 'digital' : 'analog';
      return confirm(`Discard unsaved ${area} profile editor changes before ${actionLabel}?`);
    }

    function setProfileEditorTab(tab) {
      const next = tab === 'digital' ? 'digital' : 'analog';
      const previous = state.profileEditor.tab === 'digital' ? 'digital' : 'analog';
      if (next !== previous && !profileEditorConfirmDiscard(previous, `switching to ${next}`)) {
        return false;
      }
      state.profileEditor.tab = next;
      if (els.profileEditorTabAnalog) els.profileEditorTabAnalog.classList.toggle('active', next === 'analog');
      if (els.profileEditorTabDigital) els.profileEditorTabDigital.classList.toggle('active', next === 'digital');
      if (els.profileEditorPanelAnalog) els.profileEditorPanelAnalog.classList.toggle('hidden', next !== 'analog');
      if (els.profileEditorPanelDigital) els.profileEditorPanelDigital.classList.toggle('hidden', next !== 'digital');
      if (next === 'digital') {
        refreshDigitalProfiles();
        refreshDigitalListen();
      }
      return true;
    }

    function openProfileEditorSidecar(tab = null) {
      if (state.profileLoopUi.open) {
        closeProfileLoopSidecar();
      }
      if (tab) {
        const changed = setProfileEditorTab(tab);
        if (!changed) return;
      }
      state.profileEditor.open = true;
      if (els.profileSidecar) {
        els.profileSidecar.classList.add('open');
        els.profileSidecar.setAttribute('aria-hidden', 'false');
      }
      if (els.profileSidecarOverlay) {
        els.profileSidecarOverlay.classList.remove('hidden');
      }
      refreshProfileEditorOptions();
      if (state.profileEditor.tab === 'digital') {
        refreshDigitalProfiles();
        refreshDigitalListen();
      }
    }

    function closeProfileEditorSidecar() {
      if (profileEditorAnyUnsaved() && !confirm('You have unsaved Profile Editor changes. Close anyway?')) {
        return false;
      }
      state.profileEditor.open = false;
      if (els.profileSidecar) {
        els.profileSidecar.classList.remove('open');
        els.profileSidecar.setAttribute('aria-hidden', 'true');
      }
      if (els.profileSidecarOverlay) {
        els.profileSidecarOverlay.classList.add('hidden');
      }
      return true;
    }

    function setProfileLoopTab(tab) {
      const next = tab === 'digital' ? 'digital' : 'analog';
      state.profileLoopUi.tab = next;
      if (els.profileLoopTabAnalog) els.profileLoopTabAnalog.classList.toggle('active', next === 'analog');
      if (els.profileLoopTabDigital) els.profileLoopTabDigital.classList.toggle('active', next === 'digital');
      if (els.profileLoopPanelAnalog) els.profileLoopPanelAnalog.classList.toggle('hidden', next !== 'analog');
      if (els.profileLoopPanelDigital) els.profileLoopPanelDigital.classList.toggle('hidden', next !== 'digital');
      renderProfileLoopControls();
    }

    function openProfileLoopSidecar(tab = null) {
      if (state.profileEditor.open && !closeProfileEditorSidecar()) {
        return;
      }
      if (tab) {
        setProfileLoopTab(tab);
      }
      state.profileLoopUi.open = true;
      if (els.profileLoopSidecar) {
        els.profileLoopSidecar.classList.add('open');
        els.profileLoopSidecar.setAttribute('aria-hidden', 'false');
      }
      if (els.profileLoopSidecarOverlay) {
        els.profileLoopSidecarOverlay.classList.remove('hidden');
      }
      renderProfileLoopControls();
    }

    function closeProfileLoopSidecar() {
      state.profileLoopUi.open = false;
      if (els.profileLoopSidecar) {
        els.profileLoopSidecar.classList.remove('open');
        els.profileLoopSidecar.setAttribute('aria-hidden', 'true');
      }
      if (els.profileLoopSidecarOverlay) {
        els.profileLoopSidecarOverlay.classList.add('hidden');
      }
      return true;
    }

    function _profilesForAnalogTarget(target) {
      return target === 'ground' ? (state.ground.profiles || []) : (state.airband.profiles || []);
    }

    function refreshProfileEditorOptions() {
      const target = (els.profileEditorAnalogTarget?.value || state.profileEditor.analog.target || 'airband') === 'ground'
        ? 'ground'
        : 'airband';
      state.profileEditor.analog.target = target;

      if (els.profileEditorAnalogTarget && els.profileEditorAnalogTarget.value !== target) {
        els.profileEditorAnalogTarget.value = target;
      }

      if (els.profileEditorAnalogProfile) {
        const profiles = _profilesForAnalogTarget(target).filter((p) => p && p.id);
        const current = state[target].currentProfile || '';
        let selected = String(els.profileEditorAnalogProfile.value || state.profileEditor.analog.profileId || '');
        if (!profiles.some((p) => p.id === selected)) {
          selected = current || (profiles[0] && profiles[0].id) || '';
        }
        els.profileEditorAnalogProfile.innerHTML = profiles.length
          ? profiles.map((p) => `<option value=\"${escapeHtml(p.id)}\">${escapeHtml(p.label || p.id)} (${escapeHtml(p.id)})</option>`).join('')
          : '<option value=\"\">No profiles</option>';
        els.profileEditorAnalogProfile.disabled = !profiles.length;
        els.profileEditorAnalogProfile.value = selected;
        state.profileEditor.analog.profileId = selected;
      }

      if (els.profileEditorDigitalProfile) {
        const profiles = (state.digital.profiles || []).filter(Boolean);
        const current = state.digital.activeProfile || state.digital.profile || '';
        let selected = String(els.profileEditorDigitalProfile.value || state.profileEditor.digital.profileId || '');
        if (!profiles.includes(selected)) {
          selected = current || profiles[0] || '';
        }
        els.profileEditorDigitalProfile.innerHTML = profiles.length
          ? profiles.map((id) => `<option value=\"${escapeHtml(id)}\">${escapeHtml(id)}</option>`).join('')
          : '<option value=\"\">No digital profiles</option>';
        els.profileEditorDigitalProfile.disabled = !profiles.length;
        els.profileEditorDigitalProfile.value = selected;
        state.profileEditor.digital.profileId = selected;
      }
    }

    async function loadProfileEditorAnalog() {
      const target = (els.profileEditorAnalogTarget?.value || 'airband') === 'ground' ? 'ground' : 'airband';
      const profileId = els.profileEditorAnalogProfile?.value || '';
      if (!profileId) {
        setProfileEditorStatus('analog', 'Select an analog profile first', true);
        return;
      }
      if (!profileEditorConfirmDiscard('analog', `loading ${profileId}`)) {
        return;
      }
      setProfileEditorStatus('analog', 'Loading...', false);
      try {
        const data = await fetchJSON(
          `/api/profile-editor/analog?id=${encodeURIComponent(profileId)}&target=${encodeURIComponent(target)}`
        );
        if (!data || data.ok === false) {
          setProfileEditorStatus('analog', (data && data.error) || 'Load failed', true);
          return;
        }
        if (els.profileEditorAnalogModulation) {
          els.profileEditorAnalogModulation.value = data.modulation || 'am';
        }
        if (els.profileEditorAnalogBandwidth) {
          els.profileEditorAnalogBandwidth.value = Number.isFinite(data.bandwidth) ? data.bandwidth : 12000;
        }
        if (els.profileEditorAnalogFreqs) {
          els.profileEditorAnalogFreqs.value = data.freqs_text || '';
        }
        state.profileEditor.analog.profileId = profileId;
        state.profileEditor.analog.target = target;
        setProfileEditorDirty('analog', false);
        setProfileEditorStatus('analog', `Loaded ${profileId}`, false);
      } catch (e) {
        setProfileEditorStatus('analog', 'Load failed', true);
      }
    }

    async function saveProfileEditorAnalog() {
      const target = (els.profileEditorAnalogTarget?.value || 'airband') === 'ground' ? 'ground' : 'airband';
      const profileId = els.profileEditorAnalogProfile?.value || '';
      const modulation = (els.profileEditorAnalogModulation?.value || '').trim().toLowerCase();
      const bandwidth = Number(els.profileEditorAnalogBandwidth?.value || 0);
      const freqs_text = String(els.profileEditorAnalogFreqs?.value || '').trim();
      if (!profileId) {
        setProfileEditorStatus('analog', 'Select an analog profile first', true);
        return;
      }
      if (!freqs_text) {
        setProfileEditorStatus('analog', 'Frequency list is required', true);
        return;
      }
      setProfileEditorStatus('analog', 'Saving...', false);
      try {
        const res = await postJSON('/api/profile-editor/analog/save', {
          id: profileId,
          target,
          modulation,
          bandwidth,
          freqs_text,
        });
        if (!res || res.ok === false) {
          setProfileEditorStatus('analog', (res && res.error) || 'Save failed', true);
          return;
        }
        const parts = ['Saved'];
        if (res.scanner_restarted) parts.push('scanner restarted');
        setProfileEditorDirty('analog', false);
        setProfileEditorStatus('analog', parts.join(' ‚Ä¢ '), false);
        await refresh();
      } catch (e) {
        setProfileEditorStatus('analog', 'Save failed', true);
      }
    }

    async function validateProfileEditorAnalog() {
      const target = (els.profileEditorAnalogTarget?.value || 'airband') === 'ground' ? 'ground' : 'airband';
      const profileId = els.profileEditorAnalogProfile?.value || '';
      const modulation = (els.profileEditorAnalogModulation?.value || '').trim().toLowerCase();
      const bandwidth = Number(els.profileEditorAnalogBandwidth?.value || 0);
      const freqs_text = String(els.profileEditorAnalogFreqs?.value || '').trim();
      if (!profileId) {
        setProfileEditorStatus('analog', 'Select an analog profile first', true);
        return;
      }
      if (!freqs_text) {
        setProfileEditorStatus('analog', 'Frequency list is required', true);
        return;
      }
      setProfileEditorStatus('analog', 'Validating...', false);
      try {
        const res = await postJSON('/api/profile-editor/analog/validate', {
          id: profileId,
          target,
          modulation,
          bandwidth,
          freqs_text,
        });
        if (!res || res.ok === false) {
          setProfileEditorStatus('analog', (res && res.error) || 'Validation failed', true);
          return;
        }
        const bits = [
          `Valid`,
          `${res.frequency_count || 0} freqs`,
          `${res.label_count || 0} labels`,
        ];
        if (Array.isArray(res.warnings) && res.warnings.length) {
          bits.push(`warn: ${res.warnings.join('; ')}`);
        }
        setProfileEditorStatus('analog', bits.join(' ‚Ä¢ '), false);
      } catch (e) {
        setProfileEditorStatus('analog', messageFromError(e, 'Validation failed'), true);
      }
    }

    async function loadProfileEditorDigital() {
      const profileId = els.profileEditorDigitalProfile?.value || '';
      if (!profileId) {
        setProfileEditorStatus('digital', 'Select a digital profile first', true);
        return;
      }
      if (!profileEditorConfirmDiscard('digital', `loading ${profileId}`)) {
        return;
      }
      setProfileEditorStatus('digital', 'Loading...', false);
      try {
        const data = await fetchJSON(`/api/profile-editor/digital?profileId=${encodeURIComponent(profileId)}`);
        if (!data || data.ok === false) {
          setProfileEditorStatus('digital', (data && data.error) || 'Load failed', true);
          return;
        }
        if (els.profileEditorDigitalControls) {
          els.profileEditorDigitalControls.value = data.control_channels_text || '';
        }
        if (els.profileEditorDigitalSystems) {
          els.profileEditorDigitalSystems.value = data.systems_json_text || '';
        }
        if (els.profileEditorDigitalTalkgroups) {
          els.profileEditorDigitalTalkgroups.value = data.talkgroups_text || '';
        }
        state.profileEditor.digital.profileId = profileId;
        setProfileEditorDirty('digital', false);
        const systemCount = Number.isFinite(data.systems_count) ? data.systems_count : 0;
        const summary = systemCount > 0
          ? `Loaded ${profileId} (${data.talkgroups_count || 0} TGs, ${systemCount} systems)`
          : `Loaded ${profileId} (${data.talkgroups_count || 0} TGs)`;
        setProfileEditorStatus('digital', summary, false);
      } catch (e) {
        setProfileEditorStatus('digital', 'Load failed', true);
      }
    }

    async function saveProfileEditorDigital() {
      const profileId = els.profileEditorDigitalProfile?.value || '';
      const control_channels_text = String(els.profileEditorDigitalControls?.value || '').trim();
      const systems_json_text = String(els.profileEditorDigitalSystems?.value || '').trim();
      const talkgroups_text = String(els.profileEditorDigitalTalkgroups?.value || '').trim();
      if (!profileId) {
        setProfileEditorStatus('digital', 'Select a digital profile first', true);
        return;
      }
      if (!control_channels_text && !systems_json_text) {
        setProfileEditorStatus('digital', 'Provide control channels or systems JSON', true);
        return;
      }
      if (!talkgroups_text) {
        setProfileEditorStatus('digital', 'Talkgroups CSV is required', true);
        return;
      }
      setProfileEditorStatus('digital', 'Saving...', false);
      try {
        const res = await postJSON('/api/profile-editor/digital/save', {
          profileId,
          control_channels_text,
          systems_json_text,
          talkgroups_text,
          apply_now: true,
        });
        if (!res || res.ok === false) {
          setProfileEditorStatus('digital', (res && res.error) || 'Save failed', true);
          return;
        }
        const bits = ['Saved'];
        if (res.runtime_applied) bits.push('runtime reloaded');
        if (res.runtime_error) bits.push(`runtime: ${res.runtime_error}`);
        setProfileEditorDirty('digital', false);
        setProfileEditorStatus('digital', bits.join(' ‚Ä¢ '), Boolean(res.runtime_error));
        digitalListenLoaded = false;
        await refreshDigitalListen(true);
        await refresh();
      } catch (e) {
        setProfileEditorStatus('digital', 'Save failed', true);
      }
    }

    async function validateProfileEditorDigital() {
      const profileId = els.profileEditorDigitalProfile?.value || '';
      const control_channels_text = String(els.profileEditorDigitalControls?.value || '').trim();
      const systems_json_text = String(els.profileEditorDigitalSystems?.value || '').trim();
      const talkgroups_text = String(els.profileEditorDigitalTalkgroups?.value || '').trim();
      if (!profileId) {
        setProfileEditorStatus('digital', 'Select a digital profile first', true);
        return;
      }
      if (!control_channels_text && !systems_json_text) {
        setProfileEditorStatus('digital', 'Provide control channels or systems JSON', true);
        return;
      }
      if (!talkgroups_text) {
        setProfileEditorStatus('digital', 'Talkgroups CSV is required', true);
        return;
      }
      setProfileEditorStatus('digital', 'Validating...', false);
      try {
        const res = await postJSON('/api/profile-editor/digital/validate', {
          profileId,
          control_channels_text,
          systems_json_text,
          talkgroups_text,
        });
        if (!res || res.ok === false) {
          setProfileEditorStatus('digital', (res && res.error) || 'Validation failed', true);
          return;
        }
        const bits = [
          'Valid',
          `${res.talkgroups || 0} TGs`,
          `${res.control_channels || 0} controls`,
          `${res.systems || 0} systems`,
        ];
        if (Number.isFinite(res.encrypted_talkgroups) && Number.isFinite(res.clear_talkgroups)) {
          bits.push(`${res.clear_talkgroups} clear / ${res.encrypted_talkgroups} encrypted`);
        }
        if (Array.isArray(res.warnings) && res.warnings.length) {
          bits.push(`warn: ${res.warnings.join('; ')}`);
        }
        setProfileEditorStatus('digital', bits.join(' ‚Ä¢ '), false);
      } catch (e) {
        setProfileEditorStatus('digital', messageFromError(e, 'Validation failed'), true);
      }
    }

    function loadActiveProfileEditorTab() {
      const tab = state.profileEditor?.tab === 'digital' ? 'digital' : 'analog';
      if (tab === 'digital') {
        loadProfileEditorDigital();
        return;
      }
      loadProfileEditorAnalog();
    }

    async function createProfileEditorAnalog() {
      const target = (els.profileEditorAnalogTarget?.value || state.profileEditor?.analog?.target || 'airband') === 'ground'
        ? 'ground'
        : 'airband';
      const rawId = prompt(`New ${target} profile ID`, '');
      if (rawId === null) return;
      const profileId = sanitizeProfileId(rawId);
      if (!profileId) {
        setProfileEditorStatus('analog', 'Enter a valid profile ID', true);
        return;
      }
      setProfileEditorStatus('analog', `Creating ${profileId}...`, false);
      try {
        await postAPI('/api/profile/create', {
          id: profileId,
          label: profileId,
          airband: target === 'airband',
        });
        await refresh();
        state.profileEditor.analog.target = target;
        state.profileEditor.analog.profileId = profileId;
        refreshProfileEditorOptions();
        if (els.profileEditorAnalogTarget) els.profileEditorAnalogTarget.value = target;
        if (els.profileEditorAnalogProfile) els.profileEditorAnalogProfile.value = profileId;
        setProfileEditorDirty('analog', false);
        await loadProfileEditorAnalog();
        logActivity(`Created ${target} profile ${profileId}`, 'info', `profile-create-${target}-${profileId}`);
      } catch (e) {
        const msg = messageFromError(e, 'Create failed');
        setProfileEditorStatus('analog', msg, true);
      }
    }

    async function createProfileEditorDigital() {
      const rawId = prompt('New digital profile ID', '');
      if (rawId === null) return;
      const profileId = sanitizeDigitalProfileId(rawId);
      if (!profileId) {
        setProfileEditorStatus('digital', 'Enter a valid profile ID', true);
        return;
      }
      setProfileEditorStatus('digital', `Creating ${profileId}...`, false);
      try {
        await postAPI('/api/digital/profile/create', { profileId });
        await refreshDigitalProfiles(true);
        state.profileEditor.digital.profileId = profileId;
        refreshProfileEditorOptions();
        if (els.profileEditorDigitalProfile) els.profileEditorDigitalProfile.value = profileId;
        setProfileEditorDirty('digital', false);
        await loadProfileEditorDigital();
        digitalListenLoaded = false;
        await refreshDigitalListen(true);
        logActivity(`Created digital profile ${profileId}`, 'info', `digital-profile-create-${profileId}`);
      } catch (e) {
        const msg = messageFromError(e, 'Create failed');
        setProfileEditorStatus('digital', msg, true);
      }
    }

    function createActiveProfileEditorTab() {
      const tab = state.profileEditor?.tab === 'digital' ? 'digital' : 'analog';
      if (tab === 'digital') {
        createProfileEditorDigital();
        return;
      }
      createProfileEditorAnalog();
    }

    async function deleteProfileEditorAnalog() {
      const target = (els.profileEditorAnalogTarget?.value || state.profileEditor?.analog?.target || 'airband') === 'ground'
        ? 'ground'
        : 'airband';
      const profileId = String(els.profileEditorAnalogProfile?.value || state.profileEditor?.analog?.profileId || '').trim();
      if (!profileId) {
        setProfileEditorStatus('analog', 'Select an analog profile first', true);
        return;
      }
      if (!profileEditorConfirmDiscard('analog', `deleting ${profileId}`)) {
        return;
      }
      if (!confirm(`Delete ${target} profile ${profileId}?`)) {
        return;
      }
      setProfileEditorStatus('analog', `Deleting ${profileId}...`, false);
      try {
        await postAPI('/api/profile/delete', { id: profileId });
        setProfileEditorDirty('analog', false);
        await refresh();
        state.profileEditor.analog.target = target;
        refreshProfileEditorOptions();
        const nextId = String(els.profileEditorAnalogProfile?.value || '').trim();
        if (nextId) {
          await loadProfileEditorAnalog();
          setProfileEditorStatus('analog', `Deleted ${profileId} ‚Ä¢ loaded ${nextId}`, false);
        } else {
          if (els.profileEditorAnalogModulation) els.profileEditorAnalogModulation.value = 'am';
          if (els.profileEditorAnalogBandwidth) els.profileEditorAnalogBandwidth.value = 12000;
          if (els.profileEditorAnalogFreqs) els.profileEditorAnalogFreqs.value = '';
          setProfileEditorStatus('analog', `Deleted ${profileId}`, false);
        }
        logActivity(`Deleted ${target} profile ${profileId}`, 'info', `profile-editor-delete-${target}-${profileId}`);
      } catch (e) {
        setProfileEditorStatus('analog', messageFromError(e, 'Delete failed'), true);
      }
    }

    async function deleteProfileEditorDigital() {
      const profileId = String(els.profileEditorDigitalProfile?.value || state.profileEditor?.digital?.profileId || '').trim();
      if (!profileId) {
        setProfileEditorStatus('digital', 'Select a digital profile first', true);
        return;
      }
      if (!profileEditorConfirmDiscard('digital', `deleting ${profileId}`)) {
        return;
      }
      if (!confirm(`Delete digital profile ${profileId}?`)) {
        return;
      }
      setProfileEditorStatus('digital', `Deleting ${profileId}...`, false);
      try {
        await postAPI('/api/digital/profile/delete', { profileId });
        setProfileEditorDirty('digital', false);
        state.digitalListen.items = [];
        state.digitalListen.profile = '';
        state.digitalListen.dirty = false;
        digitalListenLoaded = false;
        renderDigitalListenList();
        await refreshDigitalProfiles(true);
        await refresh();
        refreshProfileEditorOptions();
        const nextId = String(els.profileEditorDigitalProfile?.value || '').trim();
        if (nextId) {
          await loadProfileEditorDigital();
          await refreshDigitalListen(true);
          setProfileEditorStatus('digital', `Deleted ${profileId} ‚Ä¢ loaded ${nextId}`, false);
        } else {
          if (els.profileEditorDigitalControls) els.profileEditorDigitalControls.value = '';
          if (els.profileEditorDigitalSystems) els.profileEditorDigitalSystems.value = '';
          if (els.profileEditorDigitalTalkgroups) els.profileEditorDigitalTalkgroups.value = '';
          setProfileEditorStatus('digital', `Deleted ${profileId}`, false);
          setDigitalListenStatus('Select a profile first', false);
        }
        logActivity(`Deleted digital profile ${profileId}`, 'info', `digital-profile-delete-${profileId}`);
      } catch (e) {
        setProfileEditorStatus('digital', messageFromError(e, 'Delete failed'), true);
      }
    }

    function buildProxyStreamUrl(mountName, fallbackMount) {
      const mount = (mountName || fallbackMount).replace(/^\/+/, '');
      if (state.streamProxyEnabled) {
        return `${location.origin}/stream/${encodeURIComponent(mount)}`;
      }
      const port = Number.isFinite(state.icecastPort) ? state.icecastPort : 8000;
      return `http://${location.hostname}:${port}/${mount}`;
    }

    function buildIcecastUrl(mountName, fallbackMount) {
      const mount = (mountName || fallbackMount).replace(/^\/+/, '');
      const port = Number.isFinite(state.icecastPort) ? state.icecastPort : 8000;
      return `http://${location.hostname}:${port}/${mount}`;
    }

    function isLikelyIOSClient() {
      const ua = String(navigator.userAgent || '');
      if (/iPad|iPhone|iPod/i.test(ua)) return true;
      return /Macintosh/i.test(ua) && (Number(navigator.maxTouchPoints || 0) > 1);
    }

    function shouldPreferDirectIcecastStream() {
      if (!state.streamProxyEnabled) return true;
      return false;
    }

    function analogStreamUrl() {
      if (shouldPreferDirectIcecastStream()) {
        return buildIcecastUrl(state.streamMount, 'ANALOG.mp3');
      }
      return `${buildProxyStreamUrl(state.streamMount, 'ANALOG.mp3')}?transcode=1`;
    }

    function digitalStreamUrl() {
      if (shouldPreferDirectIcecastStream()) {
        return buildIcecastUrl(state.digitalStreamMount, 'DIGITAL.mp3');
      }
      return `${buildProxyStreamUrl(state.digitalStreamMount, 'DIGITAL.mp3')}?transcode=1`;
    }

    function audioTargetLabel(audioEl) {
      if (audioEl === els.audioPlayerDigital) return 'Digital';
      return 'Analog';
    }

    function ensureAudioAudible(audioEl) {
      if (!audioEl) return;
      if (audioEl.muted) audioEl.muted = false;
      const volume = Number(audioEl.volume);
      if (!Number.isFinite(volume) || volume <= 0) {
        audioEl.volume = 1;
      }
    }

    function normalizeAudioUrl(url) {
      try {
        const parsed = new URL(String(url || ''), location.href);
        return `${parsed.origin}${parsed.pathname}${parsed.search}`;
      } catch (e) {
        return String(url || '');
      }
    }

    function requestAudioPlay(audioEl, reasonKey = 'play') {
      if (!audioEl) return;
      ensureAudioAudible(audioEl);
      const playPromise = audioEl.play();
      if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch((err) => {
          const msg = messageFromError(err, 'play blocked');
          if (/interrupted by a new load request/i.test(msg)) {
            return;
          }
          const label = audioTargetLabel(audioEl);
          logActivity(`${label} player ${msg}`, 'warn', `audio-play-failed-${label}-${reasonKey}`);
        });
      }
    }

    function syncAudioSource(audioEl, base) {
      if (!audioEl) return;
      const current = normalizeAudioUrl(audioEl.currentSrc || audioEl.src || '');
      const next = normalizeAudioUrl(base);
      if (current !== next) {
        const wasPaused = audioEl.paused;
        const wantsPlay = audioEl.dataset.wantplay === '1';
        const shouldPlay = wantsPlay || !wasPaused;
        if (shouldPlay) {
          audioEl.dataset.wantplay = '1';
        }
        audioEl.src = next;
        audioEl.load();
        if (shouldPlay) {
          requestAudioPlay(audioEl, 'sync-source');
        }
      }
    }

    function syncStreamLinks() {
      const analogBase = analogStreamUrl();
      const digitalBase = digitalStreamUrl();
      if (els.lnkStreamAnalog) {
        els.lnkStreamAnalog.href = analogBase;
      }
      if (els.lnkStreamDigital) {
        els.lnkStreamDigital.href = digitalBase;
      }
      syncAudioSource(els.audioPlayerAnalog, analogBase);
      syncAudioSource(els.audioPlayerDigital, digitalBase);
      state.streamBaseUrl = analogBase;
      state.digitalStreamBaseUrl = digitalBase;
    }

    function reloadStreamPlayer(audioEl, base, stateKey, reason, keyPrefix, forcePlay = false) {
      if (!audioEl) return;
      state[stateKey] = base;
      const wasPaused = audioEl.paused;
      const wantsPlay = audioEl.dataset.wantplay === '1';
      const shouldPlay = forcePlay || wantsPlay || !wasPaused;
      if (shouldPlay) {
        audioEl.dataset.wantplay = '1';
      }
      audioEl.removeAttribute('src');
      audioEl.load();
      audioEl.src = base;
      audioEl.load();
      if (shouldPlay) {
        requestAudioPlay(audioEl, `reload-${reason || 'manual'}`);
      }
      if (reason) {
        logActivity(reason, 'info', `${keyPrefix}-${reason}`);
      }
    }

    function reloadAnalogStream(reason, forcePlay = false) {
      reloadStreamPlayer(els.audioPlayerAnalog, analogStreamUrl(), 'streamBaseUrl', reason, 'stream-reload-analog', forcePlay);
    }

    function reloadDigitalStream(reason, forcePlay = false) {
      reloadStreamPlayer(els.audioPlayerDigital, digitalStreamUrl(), 'digitalStreamBaseUrl', reason, 'stream-reload-digital', forcePlay);
    }

    function scheduleStreamRecovery(kind, reason, forcePlay = false) {
      const normalized = kind === 'digital' ? 'digital' : 'analog';
      const reloadFn = normalized === 'digital' ? reloadDigitalStream : reloadAnalogStream;
      const timers = state.streamRecoveryTimers?.[normalized] || [];
      if (timers.length) {
        timers.forEach((id) => clearTimeout(id));
      }
      state.streamRecoveryTimers[normalized] = [];
      if (!forcePlay) return;
      const timerId = setTimeout(() => {
        reloadFn(`${reason}-1`, true);
      }, 1200);
      state.streamRecoveryTimers[normalized].push(timerId);
    }

    function getAudioRecoverTracker(audioEl) {
      if (!audioEl) return null;
      let tracker = audioRecoverState.get(audioEl);
      if (!tracker) {
        tracker = {
          waitingTimer: null,
          progressTimer: null,
          lastPosition: -1,
          lastAdvanceTs: 0,
          recoverLastTs: 0,
        };
        audioRecoverState.set(audioEl, tracker);
      }
      return tracker;
    }

    function clearAudioWaitingTimer(audioEl) {
      const tracker = getAudioRecoverTracker(audioEl);
      if (tracker && tracker.waitingTimer) {
        clearTimeout(tracker.waitingTimer);
        tracker.waitingTimer = null;
      }
    }

    function markAudioProgress(audioEl) {
      if (!audioEl) return;
      const pos = Number(audioEl.currentTime || 0);
      if (!Number.isFinite(pos)) return;
      const tracker = getAudioRecoverTracker(audioEl);
      if (!tracker) return;
      tracker.lastPosition = pos;
      tracker.lastAdvanceTs = Date.now();
    }

    function maybeAutoRecoverAudio(audioEl, reloadFn, reason, allowPaused = false) {
      if (!audioEl || typeof reloadFn !== 'function') return;
      const wantsPlay = audioEl.dataset.wantplay === '1';
      if (!allowPaused && audioEl.paused && !wantsPlay) return;
      const tracker = getAudioRecoverTracker(audioEl);
      if (!tracker) return;
      const now = Date.now();
      if ((now - tracker.recoverLastTs) < AUDIO_RECOVER_COOLDOWN_MS) return;
      tracker.recoverLastTs = now;
      const forcePlay = Boolean(wantsPlay);
      reloadFn(`auto-${reason}`, forcePlay);
    }

    function checkAudioProgress(audioEl, reloadFn) {
      if (!audioEl) return;
      if (audioEl.paused) {
        if (audioEl.dataset.wantplay === '1') {
          maybeAutoRecoverAudio(audioEl, reloadFn, 'paused', true);
        }
        return;
      }
      // Live streams frequently report static/unknown duration and non-advancing
      // currentTime, so "no-progress" detection produces false recover loops.
      const duration = Number(audioEl.duration);
      const liveLike = !Number.isFinite(duration) || duration <= 0;
      if (liveLike) return;
      const pos = Number(audioEl.currentTime || 0);
      if (!Number.isFinite(pos)) return;
      const tracker = getAudioRecoverTracker(audioEl);
      if (!tracker) return;
      const now = Date.now();
      if (tracker.lastPosition < 0 || pos > (tracker.lastPosition + 0.05)) {
        tracker.lastPosition = pos;
        tracker.lastAdvanceTs = now;
        return;
      }
      if (!tracker.lastAdvanceTs) {
        tracker.lastAdvanceTs = now;
        return;
      }
      if ((now - tracker.lastAdvanceTs) >= AUDIO_PROGRESS_STALL_MS) {
        maybeAutoRecoverAudio(audioEl, reloadFn, 'no-progress');
        tracker.lastAdvanceTs = now;
      }
    }

    function bindAudioAutoRecover(audioEl, reloadFn) {
      if (!audioEl || typeof reloadFn !== 'function') return;
      const tracker = getAudioRecoverTracker(audioEl);
      if (!tracker) return;
      if (audioEl.dataset.autorecoverBound === '1') return;
      audioEl.dataset.autorecoverBound = '1';
      const targetLabel = audioEl === els.audioPlayerDigital ? 'Digital' : 'Analog';
      audioEl.addEventListener('play', () => {
        ensureAudioAudible(audioEl);
        audioEl.dataset.wantplay = '1';
      });
      audioEl.addEventListener('pause', () => {
        audioEl.dataset.wantplay = '0';
      });
      audioEl.addEventListener('playing', () => {
        clearAudioWaitingTimer(audioEl);
        markAudioProgress(audioEl);
      });
      audioEl.addEventListener('canplay', () => {
        clearAudioWaitingTimer(audioEl);
        markAudioProgress(audioEl);
      });
      audioEl.addEventListener('timeupdate', () => markAudioProgress(audioEl));
      audioEl.addEventListener('waiting', () => {
        clearAudioWaitingTimer(audioEl);
        tracker.waitingTimer = setTimeout(() => {
          tracker.waitingTimer = null;
          maybeAutoRecoverAudio(audioEl, reloadFn, 'waiting', true);
        }, AUDIO_WAITING_GRACE_MS);
      });
      audioEl.addEventListener('stalled', () => {
        maybeAutoRecoverAudio(audioEl, reloadFn, 'stalled', true);
      });
      audioEl.addEventListener('error', () => {
        const code = Number(audioEl.error && audioEl.error.code);
        const codeLabel = Number.isFinite(code) && code > 0 ? String(code) : 'unknown';
        const src = (audioEl.currentSrc || audioEl.src || '').split('?')[0];
        const suffix = src ? ` (${src})` : '';
        logActivity(`${targetLabel} player media error code ${codeLabel}${suffix}`, 'warn', `audio-error-${targetLabel}-${codeLabel}`);
        maybeAutoRecoverAudio(audioEl, reloadFn, 'error', true);
      });
      audioEl.addEventListener('emptied', () => {
        maybeAutoRecoverAudio(audioEl, reloadFn, 'emptied', true);
      });
      audioEl.addEventListener('ended', () => {
        maybeAutoRecoverAudio(audioEl, reloadFn, 'ended', true);
      });
    }

    function setupAudioAutoRecover() {
      bindAudioAutoRecover(els.audioPlayerAnalog, reloadAnalogStream);
      bindAudioAutoRecover(els.audioPlayerDigital, reloadDigitalStream);
    }

    function normalizeVlcTarget(target) {
      return target === 'digital' ? 'digital' : 'analog';
    }

    function vlcStateFor(target) {
      return state.vlc[normalizeVlcTarget(target)];
    }

    function vlcButtonFor(target) {
      return normalizeVlcTarget(target) === 'digital' ? els.btnPlayDigital : els.btnPlayAnalog;
    }

    function vlcMountFor(target) {
      return normalizeVlcTarget(target) === 'digital' ? state.digitalStreamMount : state.streamMount;
    }

    function applyVlcTargetsStatus(targets) {
      const analogRunning = !!targets?.analog;
      const digitalRunning = !!targets?.digital;
      const analogBtn = vlcButtonFor('analog');
      const digitalBtn = vlcButtonFor('digital');
      state.vlc.analog.running = analogRunning;
      state.vlc.digital.running = digitalRunning;
      if (analogBtn) {
        analogBtn.textContent = analogRunning ? 'Stop' : 'Play';
        analogBtn.dataset.vlcState = analogRunning ? 'running' : 'stopped';
      }
      if (digitalBtn) {
        digitalBtn.textContent = digitalRunning ? 'Stop' : 'Play';
        digitalBtn.dataset.vlcState = digitalRunning ? 'running' : 'stopped';
      }
      updateSitrep();
    }

    async function refreshVlcStatus() {
      try {
        const res = await postAPI('/api/vlc', { action: 'status' });
        if (res && res.ok) {
          if (res.targets && typeof res.targets === 'object') {
            applyVlcTargetsStatus(res.targets);
          } else {
            applyVlcTargetsStatus({ analog: !!res.running, digital: false });
          }
        }
      } catch (e) {
        console.error('VLC status failed:', e);
      }
    }

    async function toggleVlcPlayback(target) {
      const resolvedTarget = normalizeVlcTarget(target);
      const targetState = vlcStateFor(resolvedTarget);
      const button = vlcButtonFor(resolvedTarget);
      if (!targetState || !button || targetState.busy) return;
      targetState.busy = true;
      const action = targetState.running ? 'stop' : 'start';
      button.disabled = true;
      try {
        const res = await postAPI('/api/vlc', {
          action,
          target: resolvedTarget,
          mount: vlcMountFor(resolvedTarget),
        });
        if (res && res.ok) {
          if (res.targets && typeof res.targets === 'object') {
            applyVlcTargetsStatus(res.targets);
          } else {
            applyVlcTargetsStatus({
              analog: resolvedTarget === 'analog' ? action === 'start' : state.vlc.analog.running,
              digital: resolvedTarget === 'digital' ? action === 'start' : state.vlc.digital.running,
            });
          }
          const label = resolvedTarget === 'digital' ? 'Digital' : 'Analog';
          logActivity(
            `${label} local playback ${action === 'start' ? 'started' : 'stopped'}`,
            'info',
            `vlc-${resolvedTarget}-${action}`
          );
        } else {
          console.error('VLC action failed:', res);
          await refreshVlcStatus();
        }
      } catch (e) {
        console.error('VLC action failed:', e);
        await refreshVlcStatus();
      } finally {
        targetState.busy = false;
        button.disabled = false;
      }
    }

    function sanitizeProfileId(label) {
      return String(label || '')
        .toLowerCase()
        .replace(/[^a-z0-9 _-]/g, '')
        .trim()
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .slice(0, 40);
    }

    function sanitizeDigitalProfileId(label) {
      let value = String(label || '').trim();
      value = value.replace(/[^A-Za-z0-9._@-]/g, '-').replace(/-+/g, '-');
      value = value.replace(/^[^A-Za-z0-9]+/, '');
      return value.slice(0, 64);
    }

    function getManageTarget() {
      return els.manageTargetGround && els.manageTargetGround.checked ? 'ground' : 'airband';
    }

    function refreshManageCloneOptions() {
      // Clone UI removed; keep function for older calls as a no-op.
      return;
    }

    function refreshFreqEditOptions() {
      if (!els.freqEditProfile) return;
      const target = getManageTarget();
      const list = target === 'ground' ? state.ground.profiles : state.airband.profiles;
      const currentSelection = els.freqEditProfile.value;
      els.freqEditProfile.innerHTML = '';
      list.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = `${p.label} (${p.id})`;
        els.freqEditProfile.appendChild(opt);
      });
      const activeId = target === 'ground' ? state.ground.currentProfile : state.airband.currentProfile;
      if (currentSelection && list.some(p => p.id === currentSelection)) {
        els.freqEditProfile.value = currentSelection;
      } else if (activeId) {
        els.freqEditProfile.value = activeId;
      } else if (list.length) {
        els.freqEditProfile.value = list[0].id;
      }
    }

    function formatFreqsText(freqs, labels) {
      const out = [];
      const hasLabels = Array.isArray(labels) && labels.length === freqs.length && labels.length > 0;
      for (let i = 0; i < freqs.length; i++) {
        const f = String(freqs[i] || '').trim();
        if (!f) continue;
        if (hasLabels) {
          const l = String(labels[i] || '').trim();
          out.push(l ? `${f} ${l}` : f);
        } else {
          out.push(f);
        }
      }
      return out.join('\n');
    }
    
    // ============================================
    // GAIN HELPERS
    // ============================================
    
    function gainIndexFromValue(value) {
      let best = 0;
      let bestDiff = Infinity;
      GAIN_STEPS.forEach((g, idx) => {
        const diff = Math.abs(g - value);
        if (diff < bestDiff) {
          bestDiff = diff;
          best = idx;
        }
      });
      return best;
    }
    
    function gainValueFromIndex(idx) {
      return GAIN_STEPS[Math.min(idx, GAIN_STEPS.length - 1)];
    }
    
    // ============================================
    // UI UPDATES
    // ============================================
    
    function getLiveFreqValue() {
      return getLiveFreqValueForTarget(activeTarget);
    }

    function getLiveFreqValueForTarget(target) {
      const inAirband = (f) => f >= 118 && f <= 136;
      for (let i = 0; i < state.hits.length; i++) {
        const hit = state.hits[i];
        if (!hit || !hit.freq) continue;
        const num = parseFloat(hit.freq);
        if (isNaN(num)) continue;
        if (target === 'airband' && inAirband(num)) return num;
        if (target === 'ground' && !inAirband(num)) return num;
      }
      const fallback = target === 'airband' ? state.lastHitAirband : state.lastHitGround;
      if (fallback) {
        const num = parseFloat(fallback);
        if (!isNaN(num)) return num;
      }
      return null;
    }

    function getLiveDisplayFreq() {
      const topHit = state.hits[0];
      if (topHit) {
        const raw = String(topHit.label_full || topHit.label || topHit.freq || '').trim();
        if (raw) {
          const num = parseFloat(raw);
          return isNaN(num) ? abbreviateHitText(raw, 40) : formatFreq(num) + ' MHz';
        }
      }
      if (state.lastHit) {
        const num = parseFloat(state.lastHit);
        return isNaN(num) ? state.lastHit : formatFreq(num) + ' MHz';
      }
      return '--';
    }

    function latestHitForTarget(target) {
      const inAirband = (f) => f >= 118 && f <= 136.991;
      for (let i = 0; i < state.hits.length; i++) {
        const hit = state.hits[i];
        if (!hit) continue;
        const src = String(hit.source || hit.type || '').trim().toLowerCase();
        // Keep analog cards source-true: do not infer analog source from numeric
        // digital labels/talkgroups (which can look like non-airband frequencies).
        if (src === 'digital') continue;
        if (src === target) return hit;
        const n = parseFloat(String(hit.freq || ''));
        if (!Number.isFinite(n)) continue;
        if (target === 'airband' && inAirband(n)) return hit;
        if (target === 'ground' && !inAirband(n)) return hit;
      }
      return null;
    }

    function updateStatus() {
      const airbandDisplay = getDisplayForTarget('airband');
      const groundDisplay = getDisplayForTarget('ground');
      els.lastHitAirbandValue.textContent = airbandDisplay || '--';
      els.lastHitGroundValue.textContent = groundDisplay || '--';
      const digitalHold = state.hold.digital;
      const digitalRaw = (digitalHold && digitalHold.label) || state.lastHitDigital || state.digital.lastLabel || '';
      const digitalLabel = formatDigitalLabel(digitalRaw);
      if (els.lastHitDigitalValue) {
        els.lastHitDigitalValue.textContent = digitalLabel || '--';
        els.lastHitDigitalValue.title = digitalRaw || '';
      }
      els.lastHitAirband.classList.toggle('holding', Boolean(state.hold.airband));
      els.lastHitGround.classList.toggle('holding', Boolean(state.hold.ground));
      if (els.lastHitDigital) {
        els.lastHitDigital.classList.toggle('holding', Boolean(state.hold.digital));
      }
      updateSitrep();
    }

    function getDisplayForTarget(target) {
      const holdFreq = state.hold[target];
      if (holdFreq) return holdFreq;
      if (state.tuned && state.tunedFreq && state.tunedTarget === target) {
        return formatFreq(state.tunedFreq);
      }
      const recentHit = latestHitForTarget(target);
      if (recentHit) {
        const raw = String(recentHit.label_full || recentHit.label || '').trim();
        if (raw) return abbreviateHitText(raw, 24);
      }
      const fallbackLabel = target === 'airband'
        ? state.lastHitAirbandLabel
        : state.lastHitGroundLabel;
      if (fallbackLabel) {
        return abbreviateHitText(fallbackLabel, 24);
      }
      const fallback = target === 'airband' ? state.lastHitAirband : state.lastHitGround;
      if (fallback) {
        const num = parseFloat(fallback);
        return isNaN(num) ? fallback : formatFreq(num);
      }
      return '--';
    }

    function updateControls() {
      const t = state[activeTarget];
      
      const gainIdx = gainIndexFromValue(t.gain);
      if (!els.gainSlider.classList.contains('dirty')) {
        els.gainSlider.value = gainIdx;
        els.gainValue.textContent = GAIN_STEPS[gainIdx].toFixed(1);
      }
      
      if (els.dbfsSlider && !els.dbfsSlider.classList.contains('dirty')) {
        const dbfsDisplay = Number.isFinite(t.squelch_dbfs) && t.squelch_dbfs > -1 ? -1 : t.squelch_dbfs;
        els.dbfsSlider.value = Math.round(dbfsDisplay);
        els.dbfsValue.textContent = Math.round(dbfsDisplay);
      }
      
      if (!els.filterSlider.classList.contains('dirty')) {
        els.filterSlider.value = t.filter;
        els.filterValue.textContent = t.filter;
      }
      els.filterApplied.textContent = t.filter + ' Hz';

      if (Number.isFinite(t.applied_gain)) {
        els.gainApplied.textContent = t.applied_gain.toFixed(1) + ' dB';
      } else {
        els.gainApplied.textContent = 'pending';
      }
      if (els.dbfsApplied) {
        if (Number.isFinite(t.applied_squelch_dbfs)) {
          els.dbfsApplied.textContent = Math.round(t.applied_squelch_dbfs);
        } else {
          els.dbfsApplied.textContent = 'pending';
        }
      }
      updateSitrep();
    }
    
    function updateProfiles() {
      const t = state[activeTarget];
      
      if (!t.profiles.length) {
        els.profilesList.innerHTML = '<div class="empty-state"><div class="icon">üì°</div><div>No profiles found</div></div>';
        return;
      }
      
      els.profilesList.innerHTML = t.profiles
        .filter(p => !p.id.startsWith('none_'))
        .map(p => `
          <button class="profile-btn ${p.id === t.currentProfile ? 'active' : ''}" 
                  onclick="selectProfile('${p.id}', true)">
            <div class="label">${p.label}</div>
            <div class="meta">${p.id}${p.exists ? '' : ' ‚Ä¢ Missing'}</div>
          </button>
        `).join('');
      refreshManageCloneOptions();
      refreshFreqEditOptions();
      refreshProfileEditorOptions();
      renderAnalogLoopControls();
      updateSitrep();
    }

    function normalizeProfileLoopTarget(raw, target) {
      const fallback = state.profileLoop[target] || defaultProfileLoopState();
      const out = { ...fallback };
      if (!raw || typeof raw !== 'object') return out;
      out.enabled = Boolean(raw.enabled);
      out.selectedProfiles = Array.isArray(raw.selected_profiles)
        ? raw.selected_profiles.map((item) => String(item || '').trim()).filter(Boolean)
        : out.selectedProfiles;
      out.dwellMs = Number.isFinite(raw.dwell_ms) ? Number(raw.dwell_ms) : out.dwellMs;
      out.hangMs = Number.isFinite(raw.hang_ms) ? Number(raw.hang_ms) : out.hangMs;
      out.pauseOnHit = ('pause_on_hit' in raw) ? Boolean(raw.pause_on_hit) : out.pauseOnHit;
      out.currentProfile = String(raw.current_profile || '');
      out.activeProfile = String(raw.active_profile || '');
      out.nextProfile = String(raw.next_profile || '');
      out.lastSwitchTimeMs = Number.isFinite(raw.last_switch_time_ms) ? Number(raw.last_switch_time_ms) : 0;
      out.switchReason = String(raw.switch_reason || '');
      out.lastError = String(raw.last_error || '');
      out.recentHit = Boolean(raw.recent_hit);
      out.inHitHold = Boolean(raw.in_hit_hold);
      out.blockedReason = String(raw.blocked_reason || '');
      out.availableProfiles = Array.isArray(raw.available_profiles)
        ? raw.available_profiles
          .map((item) => {
            if (typeof item === 'string') {
              const id = String(item || '').trim();
              return id ? { id, label: id } : null;
            }
            if (!item || typeof item !== 'object') return null;
            const id = String(item.id || '').trim();
            if (!id) return null;
            const label = String(item.label || id).trim();
            return { id, label };
          })
          .filter(Boolean)
        : out.availableProfiles;
      return out;
    }

    function applyProfileLoopPayload(payload) {
      if (!payload || typeof payload !== 'object') return;
      const targets = payload.targets && typeof payload.targets === 'object'
        ? payload.targets
        : payload;
      if (!targets || typeof targets !== 'object') return;
      ['airband', 'ground', 'digital'].forEach((target) => {
        if (!(target in targets)) return;
        const normalized = normalizeProfileLoopTarget(targets[target], target);
        const draft = getLoopDraftSelection(target);
        if (Array.isArray(draft)) {
          normalized.selectedProfiles = draft;
        }
        state.profileLoop[target] = normalized;
      });
      renderProfileLoopControls();
    }

    function loopLabelForTarget(target, profileId) {
      const pid = String(profileId || '').trim();
      if (!pid) return '';
      if (target === 'digital') {
        const list = (state.profileLoop.digital.availableProfiles || []);
        const match = list.find((row) => row && row.id === pid);
        return match ? match.label : pid;
      }
      const rows = (state[target]?.profiles || []).filter((row) => row && !String(row.id || '').startsWith('none_'));
      const match = rows.find((row) => String(row.id || '') === pid);
      return match ? String(match.label || pid) : pid;
    }

    function fallbackLoopProfiles(target) {
      if (target === 'digital') {
        return (state.digital.profiles || []).map((id) => ({ id: String(id || ''), label: String(id || '') })).filter((row) => row.id);
      }
      return (state[target]?.profiles || [])
        .filter((row) => row && !String(row.id || '').startsWith('none_'))
        .map((row) => ({ id: String(row.id || ''), label: String(row.label || row.id || '') }))
        .filter((row) => row.id);
    }

    function normalizeLoopTarget(target) {
      if (target === 'ground') return 'ground';
      if (target === 'digital') return 'digital';
      return 'airband';
    }

    function normalizeProfileIdList(items) {
      if (!Array.isArray(items)) return [];
      const out = [];
      items.forEach((item) => {
        const id = String(item || '').trim();
        if (!id || out.includes(id)) return;
        out.push(id);
      });
      return out;
    }

    function getLoopDraftSelection(target) {
      const name = normalizeLoopTarget(target);
      const drafts = state.profileLoopUi?.draftSelected;
      if (!drafts || !Object.prototype.hasOwnProperty.call(drafts, name)) return null;
      return Array.isArray(drafts[name]) ? normalizeProfileIdList(drafts[name]) : null;
    }

    function setLoopDraftSelection(target, items) {
      const name = normalizeLoopTarget(target);
      if (!state.profileLoopUi.draftSelected) {
        state.profileLoopUi.draftSelected = { airband: null, ground: null, digital: null };
      }
      state.profileLoopUi.draftSelected[name] = normalizeProfileIdList(items);
    }

    function clearLoopDraftSelection(target) {
      const name = normalizeLoopTarget(target);
      if (!state.profileLoopUi.draftSelected) return;
      state.profileLoopUi.draftSelected[name] = null;
    }

    function selectedLoopProfilesForUi(target, loopState) {
      const draft = getLoopDraftSelection(target);
      if (Array.isArray(draft)) return draft;
      return normalizeProfileIdList(loopState?.selectedProfiles || []);
    }

    function localLoopState(target) {
      const name = normalizeLoopTarget(target);
      if (!state.profileLoop[name]) {
        state.profileLoop[name] = name === 'digital'
          ? { ...defaultProfileLoopState(), dwellMs: 30000, hangMs: 8000 }
          : defaultProfileLoopState();
      }
      return state.profileLoop[name];
    }

    function clampLoopSeconds(rawValue, fallbackSec, minSec, maxSec) {
      const raw = Number(rawValue);
      if (!Number.isFinite(raw)) return fallbackSec;
      const rounded = Math.round(raw);
      if (rounded < minSec) return minSec;
      if (rounded > maxSec) return maxSec;
      return rounded;
    }

    function updateLoopLocalSettingsFromInputs(target) {
      const name = normalizeLoopTarget(target);
      const loopState = localLoopState(name);
      const isDigital = name === 'digital';
      const dwellEl = isDigital ? els.digitalLoopDwell : els.loopDwell;
      const hangEl = isDigital ? els.digitalLoopHang : els.loopHang;
      const pauseEl = isDigital ? els.digitalLoopPause : els.loopPause;
      const defaultDwellMs = isDigital ? 30000 : 45000;
      const defaultHangMs = isDigital ? 8000 : 12000;
      const fallbackDwellSec = Math.max(1, Math.round(Number(loopState.dwellMs || defaultDwellMs) / 1000));
      const fallbackHangSec = Math.max(1, Math.round(Number(loopState.hangMs || defaultHangMs) / 1000));
      const dwellSec = clampLoopSeconds(dwellEl && dwellEl.value, fallbackDwellSec, 1, 1800);
      const hangSec = clampLoopSeconds(hangEl && hangEl.value, fallbackHangSec, 1, 600);
      loopState.dwellMs = dwellSec * 1000;
      loopState.hangMs = hangSec * 1000;
      loopState.pauseOnHit = Boolean(pauseEl && pauseEl.checked);
      return loopState;
    }

    function clearLoopAutoApplyTimer(target) {
      const name = normalizeLoopTarget(target);
      const timers = state.profileLoopUi?.applyTimers;
      if (!timers || !timers[name]) return;
      clearTimeout(timers[name]);
      timers[name] = null;
    }

    function scheduleLoopAutoApply(target) {
      const name = normalizeLoopTarget(target);
      if (!state.profileLoopUi.applyTimers) {
        state.profileLoopUi.applyTimers = { airband: null, ground: null, digital: null };
      }
      clearLoopAutoApplyTimer(name);
      state.profileLoopUi.applyTimers[name] = setTimeout(() => {
        if (state.profileLoopUi.applyTimers) {
          state.profileLoopUi.applyTimers[name] = null;
        }
        applyProfileLoopConfig(name, null);
      }, 300);
    }

    function collectLoopSelection(listEl) {
      if (!listEl) return [];
      const out = [];
      listEl.querySelectorAll('input[type="checkbox"][data-profile-id]').forEach((input) => {
        if (!input.checked) return;
        const id = String(input.dataset.profileId || '').trim();
        if (!id || out.includes(id)) return;
        out.push(id);
      });
      return out;
    }

    function renderLoopChecklist(listEl, target, loopState) {
      if (!listEl) return;
      const available = Array.isArray(loopState.availableProfiles) && loopState.availableProfiles.length
        ? loopState.availableProfiles
        : fallbackLoopProfiles(target);
      if (!available.length) {
        listEl.innerHTML = '<div class="control-applied">No profiles available for loop</div>';
        return;
      }
      const selected = new Set(selectedLoopProfilesForUi(target, loopState));
      listEl.innerHTML = '';
      available.forEach((row) => {
        const id = String(row.id || '').trim();
        if (!id) return;
        const label = String(row.label || id).trim() || id;
        const wrapper = document.createElement('label');
        wrapper.className = 'loop-item';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.profileId = id;
        cb.checked = selected.has(id);
        const text = document.createElement('span');
        text.innerHTML = `<span>${escapeHtml(label)}</span> <span class="meta">(${escapeHtml(id)})</span>`;
        wrapper.appendChild(cb);
        wrapper.appendChild(text);
        listEl.appendChild(wrapper);
      });
    }

    function loopStatusTone(loopState) {
      if (!loopState) return '';
      if (loopState.enabled && !loopState.lastError) return 'good';
      if (loopState.lastError || loopState.blockedReason) return 'warn';
      return '';
    }

    function setLoopHeaderIndicator(el, target, loopState) {
      if (!el) return;
      const stateRow = loopState || defaultProfileLoopState();
      let text = 'Loop Off';
      let tone = '';
      if (stateRow.enabled) {
        if (stateRow.lastError) {
          text = 'Loop Err';
          tone = 'bad';
        } else if (stateRow.blockedReason || stateRow.inHitHold) {
          text = 'Loop Hold';
          tone = 'warn';
        } else {
          text = 'Loop On';
          tone = 'good';
        }
      }
      el.textContent = text;
      setValueTone(el, tone);
      const details = [];
      details.push(`target=${target}`);
      details.push(`enabled=${stateRow.enabled ? 'yes' : 'no'}`);
      if (stateRow.activeProfile) {
        details.push(`active=${loopLabelForTarget(target, stateRow.activeProfile)}`);
      }
      if (stateRow.nextProfile) {
        details.push(`next=${loopLabelForTarget(target, stateRow.nextProfile)}`);
      }
      if (stateRow.inHitHold) {
        details.push('holding on hit');
      }
      if (stateRow.blockedReason) {
        details.push(`blocked=${stateRow.blockedReason}`);
      }
      if (stateRow.switchReason) {
        details.push(`reason=${stateRow.switchReason}`);
      }
      if (stateRow.lastError) {
        details.push(`error=${trimServiceNote(stateRow.lastError, 80)}`);
      }
      el.title = details.join(' ‚Ä¢ ');
    }

    function renderMainLoopIndicators() {
      const analogTarget = activeTarget === 'ground' ? 'ground' : 'airband';
      const analogLoopState = state.profileLoop[analogTarget] || defaultProfileLoopState();
      const digitalLoopState = state.profileLoop.digital || defaultProfileLoopState();
      setLoopHeaderIndicator(els.profilesLoopIndicator, analogTarget, analogLoopState);
      setLoopHeaderIndicator(els.digitalProfilesLoopIndicator, 'digital', digitalLoopState);
    }

    function renderAnalogLoopControls() {
      const target = activeTarget === 'ground' ? 'ground' : 'airband';
      const loopState = state.profileLoop[target] || defaultProfileLoopState();
      renderLoopChecklist(els.loopList, target, loopState);
      if (els.loopStatus) {
        const statusText = loopState.enabled ? 'LOOPING' : 'IDLE';
        els.loopStatus.textContent = statusText;
        setValueTone(els.loopStatus, loopStatusTone(loopState));
      }
      if (els.loopDetail) {
        const parts = [];
        if (loopState.activeProfile) {
          parts.push(`active=${loopLabelForTarget(target, loopState.activeProfile)}`);
        }
        if (loopState.nextProfile) {
          parts.push(`next=${loopLabelForTarget(target, loopState.nextProfile)}`);
        }
        if (loopState.inHitHold) {
          parts.push('holding on hit');
        }
        if (loopState.blockedReason) {
          parts.push(`blocked=${loopState.blockedReason}`);
        }
        if (loopState.switchReason) {
          parts.push(`reason=${loopState.switchReason}`);
        }
        if (loopState.lastError) {
          parts.push(`error=${trimServiceNote(loopState.lastError, 120)}`);
        }
        els.loopDetail.textContent = parts.join(' ‚Ä¢ ') || '--';
      }
      if (els.loopDwell && document.activeElement !== els.loopDwell) {
        els.loopDwell.value = Math.max(1, Math.round(Number(loopState.dwellMs || 45000) / 1000));
      }
      if (els.loopHang && document.activeElement !== els.loopHang) {
        els.loopHang.value = Math.max(1, Math.round(Number(loopState.hangMs || 12000) / 1000));
      }
      if (els.loopPause) {
        els.loopPause.checked = Boolean(loopState.pauseOnHit);
      }
      if (els.loopToggle) {
        els.loopToggle.textContent = loopState.enabled ? 'Stop Loop' : 'Start Loop';
      }
      if (els.loopList) {
        els.loopList.querySelectorAll('input[type="checkbox"][data-profile-id]').forEach((cb) => {
          cb.addEventListener('change', () => {
            const ids = collectLoopSelection(els.loopList);
            state.profileLoop[target].selectedProfiles = ids;
            setLoopDraftSelection(target, ids);
            if (els.loopDetail) {
              els.loopDetail.textContent = `${ids.length} selected (pending apply)`;
            }
            scheduleLoopAutoApply(target);
          });
        });
      }
      renderMainLoopIndicators();
    }

    function renderDigitalLoopControls() {
      const target = 'digital';
      const loopState = state.profileLoop[target] || defaultProfileLoopState();
      renderLoopChecklist(els.digitalLoopList, target, loopState);
      if (els.digitalLoopStatus) {
        const statusText = loopState.enabled ? 'LOOPING' : 'IDLE';
        els.digitalLoopStatus.textContent = statusText;
        setValueTone(els.digitalLoopStatus, loopStatusTone(loopState));
      }
      if (els.digitalLoopDetail) {
        const parts = [];
        if (loopState.activeProfile) {
          parts.push(`active=${loopLabelForTarget(target, loopState.activeProfile)}`);
        }
        if (loopState.nextProfile) {
          parts.push(`next=${loopLabelForTarget(target, loopState.nextProfile)}`);
        }
        if (loopState.inHitHold) {
          parts.push('holding on hit');
        }
        if (loopState.blockedReason) {
          parts.push(`blocked=${loopState.blockedReason}`);
        }
        if (loopState.switchReason) {
          parts.push(`reason=${loopState.switchReason}`);
        }
        if (loopState.lastError) {
          parts.push(`error=${trimServiceNote(loopState.lastError, 120)}`);
        }
        els.digitalLoopDetail.textContent = parts.join(' ‚Ä¢ ') || '--';
      }
      if (els.digitalLoopDwell && document.activeElement !== els.digitalLoopDwell) {
        els.digitalLoopDwell.value = Math.max(1, Math.round(Number(loopState.dwellMs || 30000) / 1000));
      }
      if (els.digitalLoopHang && document.activeElement !== els.digitalLoopHang) {
        els.digitalLoopHang.value = Math.max(1, Math.round(Number(loopState.hangMs || 8000) / 1000));
      }
      if (els.digitalLoopPause) {
        els.digitalLoopPause.checked = Boolean(loopState.pauseOnHit);
      }
      if (els.digitalLoopToggle) {
        els.digitalLoopToggle.textContent = loopState.enabled ? 'Stop Loop' : 'Start Loop';
      }
      if (els.digitalLoopList) {
        els.digitalLoopList.querySelectorAll('input[type="checkbox"][data-profile-id]').forEach((cb) => {
          cb.addEventListener('change', () => {
            const ids = collectLoopSelection(els.digitalLoopList);
            state.profileLoop[target].selectedProfiles = ids;
            setLoopDraftSelection(target, ids);
            if (els.digitalLoopDetail) {
              els.digitalLoopDetail.textContent = `${ids.length} selected (pending apply)`;
            }
            scheduleLoopAutoApply(target);
          });
        });
      }
      renderMainLoopIndicators();
    }

    function renderProfileLoopControls() {
      renderAnalogLoopControls();
      renderDigitalLoopControls();
    }

    async function applyProfileLoopConfig(target, enabledOverride = null) {
      const targetName = normalizeLoopTarget(target);
      const isDigital = targetName === 'digital';
      const dwellEl = isDigital ? els.digitalLoopDwell : els.loopDwell;
      const hangEl = isDigital ? els.digitalLoopHang : els.loopHang;
      const pauseEl = isDigital ? els.digitalLoopPause : els.loopPause;
      const loopState = updateLoopLocalSettingsFromInputs(targetName);
      clearLoopAutoApplyTimer(targetName);
      const selectedProfiles = selectedLoopProfilesForUi(targetName, loopState);
      const dwellSec = Number(dwellEl && dwellEl.value);
      const hangSec = Number(hangEl && hangEl.value);
      const payload = {
        target: targetName,
        enabled: enabledOverride === null ? Boolean(loopState.enabled) : Boolean(enabledOverride),
        selected_profiles: selectedProfiles,
        dwell_ms: Number.isFinite(dwellSec) ? Math.round(dwellSec * 1000) : Number(loopState.dwellMs || (isDigital ? 30000 : 45000)),
        hang_ms: Number.isFinite(hangSec) ? Math.round(hangSec * 1000) : Number(loopState.hangMs || (isDigital ? 8000 : 12000)),
        pause_on_hit: Boolean(pauseEl && pauseEl.checked),
      };
      try {
        const res = await postAPI('/api/profile-loop', payload);
        if (res && res.ok) {
          clearLoopDraftSelection(targetName);
          if (res.snapshot) {
            applyProfileLoopPayload(res.snapshot);
          }
          logActivity(`Profile loop updated: ${targetName}`, 'info', `profile-loop-${targetName}`);
          return;
        }
        logActivity(formatApiError(res, `Profile loop update failed (${targetName})`), 'warn', `profile-loop-${targetName}-failed`);
      } catch (e) {
        logActivity(messageFromError(e, `Profile loop update failed (${targetName})`), 'warn', `profile-loop-${targetName}-error`);
      }
      await refresh();
    }

    function selectAllLoopProfiles(target, checked) {
      const loopState = state.profileLoop[target] || defaultProfileLoopState();
      const available = Array.isArray(loopState.availableProfiles) && loopState.availableProfiles.length
        ? loopState.availableProfiles
        : fallbackLoopProfiles(target);
      loopState.selectedProfiles = checked
        ? available.map((row) => String(row.id || '').trim()).filter(Boolean)
        : [];
      setLoopDraftSelection(target, loopState.selectedProfiles);
      scheduleLoopAutoApply(target);
      if (target === 'digital') {
        renderDigitalLoopControls();
      } else {
        renderAnalogLoopControls();
      }
    }

    function setDigitalStatusMessage(message, isError=false) {
      if (!els.digitalProfileStatus) return;
      els.digitalProfileStatus.textContent = message || '';
      els.digitalProfileStatus.style.color = isError ? '#f59e0b' : '';
    }

    function setDigitalManageStatus(message, isError=false) {
      if (!els.digitalManageStatus) return;
      els.digitalManageStatus.textContent = message || '';
      els.digitalManageStatus.style.color = isError ? '#f59e0b' : '';
    }

    function setDigitalPreviewStatus(message, isError=false) {
      if (!els.digitalPreviewStatus) return;
      els.digitalPreviewStatus.textContent = message || '';
      els.digitalPreviewStatus.style.color = isError ? '#f59e0b' : '';
    }

    function updateDigitalProfileSelect() {
      if (!els.digitalProfileSelect) return;
      const profiles = state.digital.profiles || [];
      if (!profiles.length) {
        els.digitalProfileSelect.innerHTML = '<option value="">No profiles</option>';
        els.digitalProfileSelect.disabled = true;
        return;
      }
      els.digitalProfileSelect.disabled = false;
      els.digitalProfileSelect.innerHTML = profiles.map((id) => (
        `<option value="${id}">${id}</option>`
      )).join('');
      const current = state.digital.activeProfile || state.digital.profile;
      if (current && profiles.includes(current)) {
        els.digitalProfileSelect.value = current;
      }
    }

    function updateDigitalProfilesList() {
      if (!els.digitalProfilesList) return;
      const profiles = state.digital.profiles || [];
      if (!profiles.length) {
        els.digitalProfilesList.innerHTML = '<div class="empty-state"><div class="icon">üì°</div><div>No digital profiles yet</div></div>';
        return;
      }
      const current = state.digital.activeProfile || state.digital.profile;
      els.digitalProfilesList.innerHTML = profiles.map((id) => (
        `<button class="profile-btn ${id === current ? 'active' : ''}" onclick="applyDigitalProfile('${id}')">
          <div class="label">${id}</div>
          <div class="meta">${id === current ? 'Active' : 'Select'}</div>
        </button>`
      )).join('');
    }

    function formatDigitalPreview(data) {
      const lines = [];
      const profileId = data.profileId || '';
      if (profileId) lines.push(`Profile: ${profileId}`);
      if (data.previewName) {
        lines.push(`Preview: ${data.previewName}`);
        lines.push('');
        if (data.preview) lines.push(data.preview);
        lines.push('');
      }
      const files = data.files || [];
      const suffix = data.has_more ? '+' : '';
      lines.push(`Files (${files.length}${suffix}):`);
      files.forEach((f) => lines.push(`- ${f}`));
      return lines.join('\n');
    }

    function escapeHtml(value) {
      return String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    async function refreshDigitalProfiles(force=false) {
      if (digitalProfilesLoaded && !force) return;
      const sidecarDigitalActive = state.profileEditor.open && state.profileEditor.tab === 'digital';
      if (activeView !== 'digital' && !sidecarDigitalActive && !force) return;
      try {
        const data = await fetchJSON('/api/digital/profiles');
        if (data && data.ok) {
          state.digital.profiles = data.profiles || [];
          state.digital.activeProfile = data.active || '';
          digitalProfilesLoaded = true;
          updateDigitalProfileSelect();
          updateDigitalProfilesList();
          refreshProfileEditorOptions();
          return;
        }
        setDigitalStatusMessage((data && data.error) || 'Digital profiles unavailable', true);
      } catch (e) {
        setDigitalStatusMessage('Digital profiles unavailable', true);
      }
    }

    function updateDigitalUI() {
      if (!els.digitalStatus) return;
      const d = state.digital;
      const preflight = state.preflight?.digital || null;
      let statusText = d.active ? 'Running' : 'Stopped';
      if (preflight && preflight.state === 'degraded' && d.active) {
        statusText = 'Running (Degraded)';
      } else if (preflight && preflight.state === 'failed') {
        statusText = d.active ? 'Running (Blocked)' : 'Stopped (Blocked)';
      }
      els.digitalStatus.textContent = statusText;
      if (els.digitalDot) els.digitalDot.classList.toggle('active', Boolean(d.active));
      if (els.digitalBackend) els.digitalBackend.textContent = d.backend || '--';
      if (els.digitalProfile) {
        const profileBase = d.profile || d.activeProfile || '--';
        const loopState = state.profileLoop.digital || defaultProfileLoopState();
        if (loopState.enabled) {
          const next = loopState.nextProfile || '--';
          els.digitalProfile.textContent = `${profileBase} (loop‚Üí${next})`;
        } else {
          els.digitalProfile.textContent = profileBase;
        }
      }
      const hold = state.hold.digital;
      const label = (hold && hold.label) || d.lastLabel;
      const timeMs = (hold && hold.timeMs) || d.lastTime;
      const mode = (hold && hold.mode) || d.lastMode;
      if (els.digitalLastLabel) els.digitalLastLabel.textContent = label || '--';
      if (els.digitalLastTime) els.digitalLastTime.textContent = formatTimeMs(timeMs);
      if (els.digitalLastMode) {
        if (mode) {
          els.digitalLastMode.textContent = `Mode: ${mode}`;
          els.digitalLastMode.style.display = '';
        } else {
          els.digitalLastMode.textContent = '';
          els.digitalLastMode.style.display = 'none';
        }
      }
      if (els.digitalError) {
        els.digitalError.textContent = d.lastError || '';
        els.digitalError.style.color = d.lastError ? '#f59e0b' : '';
      }
      const ccHealth = getDigitalControlChannelHealth();
      if (els.digitalCcStatus) {
        els.digitalCcStatus.textContent = ccHealth.label;
        setValueTone(els.digitalCcStatus, ccHealth.tone);
      }
      if (els.digitalCcDetail) {
        const pfNote = summarizePreflight(preflight);
        if (preflight && preflight.state === 'failed' && pfNote) {
          els.digitalCcDetail.textContent = pfNote;
        } else {
          els.digitalCcDetail.textContent = ccHealth.detail || '--';
        }
      }
      const systemHealthRows = Array.isArray(d.schedulerSystemHealth) ? d.schedulerSystemHealth : [];
      const activeSystemRow = systemHealthRows.find((row) => row && row.active) || null;
      if (els.digitalSystemHealth) {
        if (!systemHealthRows.length) {
          els.digitalSystemHealth.textContent = '--';
          setValueTone(els.digitalSystemHealth, '');
        } else {
          const summary = systemHealthRows.map((row) => formatDigitalSystemHealthRow(row)).filter(Boolean).join(' | ');
          els.digitalSystemHealth.textContent = summary || '--';
          setValueTone(
            els.digitalSystemHealth,
            activeSystemRow ? digitalSchedulerStateTone(activeSystemRow.state) : ''
          );
        }
      }
      if (els.digitalSystemHealthDetail) {
        if (!activeSystemRow) {
          els.digitalSystemHealthDetail.textContent = '--';
          setValueTone(els.digitalSystemHealthDetail, '');
        } else {
          const reason = String(activeSystemRow.reason || '').trim();
          const switchReason = String(d.schedulerSwitchReason || '').trim();
          const failures = Number(activeSystemRow.lock_failures || 0);
          const timeoutMs = Number(d.schedulerLockTimeoutMs || 0);
          const parts = [
            `Active: ${String(activeSystemRow.name || '--')}`,
            reason || 'no detail',
          ];
          if (switchReason) parts.push(`switch=${switchReason}`);
          if (timeoutMs > 0) parts.push(`timeout=${Math.round(timeoutMs / 1000)}s`);
          if (failures > 0) parts.push(`lock timeouts=${failures}`);
          els.digitalSystemHealthDetail.textContent = parts.join(' ‚Ä¢ ');
          setValueTone(els.digitalSystemHealthDetail, digitalSchedulerStateTone(activeSystemRow.state));
        }
      }
      renderDongleHealth(state.systemStats);
      updateDigitalProfileSelect();
      updateDigitalProfilesList();
      renderDigitalLoopControls();
    }

    async function runDigitalAction(action) {
      const digitalShouldResume = Boolean(
        els.audioPlayerDigital
        && (!els.audioPlayerDigital.paused || els.audioPlayerDigital.dataset.wantplay === '1')
      );
      setDigitalStatusMessage(`Digital ${action}...`, false);
      try {
        const res = await postAPI(`/api/digital/${action}`, {});
        if (res && res.ok) {
          setDigitalStatusMessage(`Digital ${action} ok`, false);
          if (action === 'restart') {
            scheduleStreamRecovery('digital', 'digital-restart', digitalShouldResume);
          }
        } else {
          setDigitalStatusMessage(formatApiError(res, `${action} failed`), true);
        }
      } catch (e) {
        setDigitalStatusMessage(messageFromError(e, `${action} failed`), true);
      }
      await refresh();
    }

    async function applyDigitalProfile(profileId) {
      if (!profileId) return;
      const digitalShouldResume = Boolean(
        els.audioPlayerDigital
        && (!els.audioPlayerDigital.paused || els.audioPlayerDigital.dataset.wantplay === '1')
      );
      setDigitalStatusMessage('Applying profile...', false);
      try {
        const res = await postAPI('/api/digital/profile', { profileId });
        if (res && res.ok) {
          setDigitalStatusMessage('Profile updated', false);
          scheduleStreamRecovery('digital', 'digital-profile', digitalShouldResume);
        } else {
          setDigitalStatusMessage(formatApiError(res, 'Profile update failed'), true);
        }
      } catch (e) {
        setDigitalStatusMessage(messageFromError(e, 'Profile update failed'), true);
      }
      await refreshDigitalProfiles(true);
      await refresh();
    }

    async function onDigitalProfileChange() {
      if (!els.digitalProfileSelect) return;
      const profileId = els.digitalProfileSelect.value;
      await applyDigitalProfile(profileId);
    }

    async function createDigitalProfile() {
      if (!els.digitalManageId) return;
      let profileId = sanitizeDigitalProfileId(els.digitalManageId.value || '');
      els.digitalManageId.value = profileId;
      if (!profileId) {
        setDigitalManageStatus('Enter a profile ID.', true);
        return;
      }
      setDigitalManageStatus('Creating...', false);
      try {
        const res = await postAPI('/api/digital/profile/create', { profileId });
        if (!res || !res.ok) {
          setDigitalManageStatus(formatApiError(res, 'Create failed'), true);
          return;
        }
        setDigitalManageStatus('Profile created', false);
        await refreshDigitalProfiles(true);
        if (els.digitalProfileSelect) {
          els.digitalProfileSelect.value = profileId;
        }
      } catch (e) {
        setDigitalManageStatus(messageFromError(e, 'Create failed'), true);
      }
    }

    async function deleteDigitalProfile() {
      const selected = els.digitalProfileSelect ? els.digitalProfileSelect.value : '';
      const profileId = selected || sanitizeDigitalProfileId(els.digitalManageId?.value || '');
      if (!profileId) return;
      if (!confirm(`Delete digital profile ${profileId}?`)) return;
      setDigitalManageStatus('Deleting...', false);
      try {
        const res = await postAPI('/api/digital/profile/delete', { profileId });
        if (!res || !res.ok) {
          setDigitalManageStatus(formatApiError(res, 'Delete failed'), true);
          return;
        }
        setDigitalManageStatus('Profile deleted', false);
        await refreshDigitalProfiles(true);
      } catch (e) {
        setDigitalManageStatus(messageFromError(e, 'Delete failed'), true);
      }
    }

    async function loadDigitalPreview() {
      const profileId = els.digitalProfileSelect ? els.digitalProfileSelect.value : '';
      if (!profileId) {
        setDigitalPreviewStatus('Select a profile first', true);
        return;
      }
      setDigitalPreviewStatus('Loading...', false);
      try {
        const res = await postAPI('/api/digital/profile/inspect', { profileId });
        if (!res || !res.ok) {
          setDigitalPreviewStatus(formatApiError(res, 'Load failed'), true);
          return;
        }
        const text = formatDigitalPreview(res);
        if (els.digitalPreviewText) {
          els.digitalPreviewText.value = text;
        }
        setDigitalPreviewStatus('Loaded', false);
      } catch (e) {
        setDigitalPreviewStatus(messageFromError(e, 'Load failed'), true);
      }
    }

    function setDigitalListenStatus(message, isError=false) {
      if (!els.digitalListenStatus) return;
      els.digitalListenStatus.textContent = message || '';
      els.digitalListenStatus.style.color = isError ? '#f59e0b' : '';
    }

    function normalizeDigitalListenMode(mode) {
      return String(mode || '').trim().toUpperCase();
    }

    function digitalListenModeMatches(itemMode, modeFilter) {
      const mode = normalizeDigitalListenMode(itemMode);
      if (modeFilter === 'all') return true;
      if (modeFilter === 'encrypted') return mode.includes('E');
      if (modeFilter === 'clear') return Boolean(mode) && !mode.includes('E');
      return mode === String(modeFilter || '').toUpperCase();
    }

    function getFilteredDigitalListenItems() {
      const items = state.digitalListen.items || [];
      const search = (state.digitalListen.search || '').toLowerCase();
      const filter = state.digitalListen.filter || 'all';
      const modeFilter = state.digitalListen.modeFilter || 'all';
      return items.filter((item) => {
        const listen = Boolean(item.listen);
        if (filter === 'listen' && !listen) return false;
        if (filter === 'muted' && listen) return false;
        if (!digitalListenModeMatches(item.mode, modeFilter)) return false;
        if (!search) return true;
        const hay = [
          item.dec,
          item.hex,
          item.alpha,
          item.description,
          item.tag,
          item.mode,
          item.rejectedGrantCount,
          item.rejectedGrantReason,
        ].join(' ').toLowerCase();
        return hay.includes(search);
      });
    }

    function getDigitalListenSortValue(item, key) {
      if (key === 'dec') {
        const dec = parseInt(item.dec, 10);
        return Number.isFinite(dec) ? dec : Number.MAX_SAFE_INTEGER;
      }
      if (key === 'mode') {
        return normalizeDigitalListenMode(item.mode);
      }
      if (key === 'label') {
        return String(item.alpha || item.description || '').toLowerCase();
      }
      if (key === 'tag') {
        return String(item.tag || '').toLowerCase();
      }
      return String(item[key] || '').toLowerCase();
    }

    function getSortedDigitalListenItems(items) {
      const key = state.digitalListen.sortKey || 'dec';
      const dir = state.digitalListen.sortDir === 'desc' ? -1 : 1;
      return items.slice().sort((a, b) => {
        const av = getDigitalListenSortValue(a, key);
        const bv = getDigitalListenSortValue(b, key);
        if (av < bv) return -1 * dir;
        if (av > bv) return 1 * dir;
        return 0;
      });
    }

    function getDigitalListenSortArrow(key) {
      const activeKey = state.digitalListen.sortKey || 'dec';
      const activeDir = state.digitalListen.sortDir || 'asc';
      if (activeKey !== key) return '‚Üï';
      return activeDir === 'desc' ? '‚ñº' : '‚ñ≤';
    }

    function setDigitalListenSort(key) {
      const nextKey = String(key || '').trim();
      if (!nextKey) return;
      if (state.digitalListen.sortKey === nextKey) {
        state.digitalListen.sortDir = state.digitalListen.sortDir === 'asc' ? 'desc' : 'asc';
      } else {
        state.digitalListen.sortKey = nextKey;
        state.digitalListen.sortDir = 'asc';
      }
      renderDigitalListenList();
    }

    function renderDigitalListenList() {
      if (!els.digitalListenList) return;
      setProfileEditorDirty('digital', Boolean(state.profileEditor?.digital?.dirty));
      if (els.digitalListenSearch && els.digitalListenSearch.value !== state.digitalListen.search) {
        els.digitalListenSearch.value = state.digitalListen.search || '';
      }
      if (els.digitalListenFilter && els.digitalListenFilter.value !== state.digitalListen.filter) {
        els.digitalListenFilter.value = state.digitalListen.filter || 'all';
      }
      if (els.digitalListenModeFilter && els.digitalListenModeFilter.value !== state.digitalListen.modeFilter) {
        els.digitalListenModeFilter.value = state.digitalListen.modeFilter || 'all';
      }
      const items = state.digitalListen.items || [];
      if (!items.length) {
        els.digitalListenList.innerHTML = '<div class="empty-state"><div class="icon">üìª</div><div>Load talkgroups to edit Listen flags</div></div>';
        setDigitalListenStatus('No talkgroups loaded', false);
        return;
      }
      const filtered = getSortedDigitalListenItems(getFilteredDigitalListenItems());
      const rows = filtered.map((item) => {
        const listen = Boolean(item.listen);
        const mode = normalizeDigitalListenMode(item.mode) || '--';
        const label = item.alpha || item.description || '';
        const rejectCount = Number(item.rejectedGrantCount || 0);
        const hasRejected = Number.isFinite(rejectCount) && rejectCount >= 3;
        const tagBase = item.tag || '--';
        const tag = hasRejected ? `${tagBase} | REJ:${rejectCount}` : tagBase;
        const tagClass = `${listen ? '' : 'muted'}${hasRejected ? ' rejected' : ''}`.trim();
        return `
        <div class="digital-listen-row">
          <input type="checkbox" data-dec="${escapeHtml(item.dec)}" ${listen ? 'checked' : ''}>
          <div>${escapeHtml(item.dec || '--')}</div>
          <div class="${listen ? '' : 'muted'}">${escapeHtml(mode)}</div>
          <div class="${listen ? '' : 'muted'}">${escapeHtml(label || '--')}</div>
          <div class="${escapeHtml(tagClass)}">${escapeHtml(tag)}</div>
        </div>
        `;
      }).join('');
      const header = `
        <div class="digital-listen-row digital-listen-row-head">
          <div></div>
          <div><button class="digital-listen-sort ${state.digitalListen.sortKey === 'dec' ? 'active' : ''}" data-sort-key="dec">TGID <span class="arrow">${getDigitalListenSortArrow('dec')}</span></button></div>
          <div><button class="digital-listen-sort ${state.digitalListen.sortKey === 'mode' ? 'active' : ''}" data-sort-key="mode">Mode <span class="arrow">${getDigitalListenSortArrow('mode')}</span></button></div>
          <div><button class="digital-listen-sort ${state.digitalListen.sortKey === 'label' ? 'active' : ''}" data-sort-key="label">Label <span class="arrow">${getDigitalListenSortArrow('label')}</span></button></div>
          <div><button class="digital-listen-sort ${state.digitalListen.sortKey === 'tag' ? 'active' : ''}" data-sort-key="tag">Tag <span class="arrow">${getDigitalListenSortArrow('tag')}</span></button></div>
        </div>
      `;
      els.digitalListenList.innerHTML = rows
        ? header + rows
        : header + '<div class="empty-state"><div class="icon">üìª</div><div>No matches</div></div>';
      const statusBits = [`${filtered.length}/${items.length}`];
      const modeFilter = state.digitalListen.modeFilter || 'all';
      if (modeFilter !== 'all') {
        if (modeFilter === 'encrypted') statusBits.push('Mode:Encrypted');
        else if (modeFilter === 'clear') statusBits.push('Mode:Clear');
        else statusBits.push(`Mode:${String(modeFilter).toUpperCase()}`);
      }
      const rejectedCount = items.filter((item) => Number(item.rejectedGrantCount || 0) >= 3).length;
      if (rejectedCount > 0) statusBits.push(`Rejected:${rejectedCount}`);
      if (state.digitalListen.dirty) statusBits.push('Unsaved');
      setDigitalListenStatus(statusBits.join(' ‚Ä¢ '), false);
    }

    function setDigitalListenForFiltered(listen) {
      const filtered = getFilteredDigitalListenItems();
      if (!filtered.length) {
        setDigitalListenStatus('No matching talkgroups', true);
        return;
      }
      filtered.forEach((item) => {
        item.listen = Boolean(listen);
      });
      state.digitalListen.dirty = true;
      renderDigitalListenList();
      setDigitalListenStatus(`${listen ? 'Selected' : 'Unselected'} ${filtered.length} talkgroups`, false);
    }

    function getEncryptedOnlyTalkgroupDecs(items) {
      const stateByDec = new Map();
      (items || []).forEach((item) => {
        const dec = String(item.dec || '').trim();
        if (!dec) return;
        if (!stateByDec.has(dec)) {
          stateByDec.set(dec, { hasEncrypted: false, hasClear: false });
        }
        const mode = normalizeDigitalListenMode(item.mode);
        const info = stateByDec.get(dec);
        if (mode.includes('E')) info.hasEncrypted = true;
        else info.hasClear = true;
      });
      const decs = new Set();
      stateByDec.forEach((info, dec) => {
        if (info.hasEncrypted && !info.hasClear) decs.add(dec);
      });
      return decs;
    }

    function muteEncryptedTalkgroups() {
      const items = state.digitalListen.items || [];
      if (!items.length) {
        setDigitalListenStatus('Load talkgroups first', true);
        return;
      }
      const encryptedOnly = getEncryptedOnlyTalkgroupDecs(items);
      if (!encryptedOnly.size) {
        setDigitalListenStatus('No encrypted talkgroups found', false);
        return;
      }
      let changed = 0;
      items.forEach((item) => {
        const dec = String(item.dec || '').trim();
        if (!dec || !encryptedOnly.has(dec)) return;
        if (item.listen !== false) {
          item.listen = false;
          changed += 1;
        }
      });
      if (changed > 0) {
        state.digitalListen.dirty = true;
      }
      renderDigitalListenList();
      setDigitalListenStatus(`Muted encrypted talkgroups (${encryptedOnly.size} TGIDs)`, false);
    }

    async function refreshDigitalListen(force=false) {
      if (!els.digitalListenList) return;
      if (digitalListenLoaded && !force) {
        renderDigitalListenList();
        return;
      }
      const sidecarDigitalActive = state.profileEditor.open && state.profileEditor.tab === 'digital';
      if (activeView !== 'digital' && !sidecarDigitalActive && !force) return;
      const editorProfileId = String(
        els.profileEditorDigitalProfile?.value
          || state.profileEditor.digital.profileId
          || ''
      ).trim();
      const profileId = editorProfileId || state.digital.activeProfile || state.digital.profile;
      if (!profileId) {
        setDigitalListenStatus('Select a profile first', true);
        return;
      }
      setDigitalListenStatus('Loading...', false);
      try {
        const res = await fetchJSON(`/api/digital/talkgroups?profileId=${encodeURIComponent(profileId)}`);
        if (!res || res.ok === false) {
          setDigitalListenStatus((res && res.error) || 'Load failed', true);
          return;
        }
        state.digitalListen.items = res.items || [];
        state.digitalListen.profile = profileId;
        state.digitalListen.dirty = false;
        digitalListenLoaded = true;
        renderDigitalListenList();
      } catch (e) {
        setDigitalListenStatus('Load failed', true);
      }
    }

    async function saveDigitalListen() {
      if (!els.digitalListenList) return;
      const profileId = state.digitalListen.profile || state.digital.activeProfile || state.digital.profile;
      if (!profileId) {
        setDigitalListenStatus('Select a profile first', true);
        return;
      }
      setDigitalListenStatus('Saving...', false);
      try {
        const items = (state.digitalListen.items || []).map((item) => ({
          dec: item.dec,
          listen: Boolean(item.listen),
        }));
        const res = await postJSON('/api/digital/talkgroups/listen', { profileId, items });
        if (!res || !res.ok) {
          setDigitalListenStatus(formatApiError(res, 'Save failed'), true);
          return;
        }
        state.digitalListen.dirty = false;
        setDigitalListenStatus('Saved', false);
        renderDigitalListenList();
      } catch (e) {
        setDigitalListenStatus(messageFromError(e, 'Save failed'), true);
      }
    }

    function setManageStatus(message, isError=false) {
      if (!els.manageStatus) return;
      els.manageStatus.textContent = message || '';
      els.manageStatus.style.color = isError ? '#f59e0b' : '';
    }

    function getManageSelectedId() {
      const target = getManageTarget();
      const selected = els.freqEditProfile && els.freqEditProfile.value;
      if (selected) return selected;
      return target === 'ground' ? state.ground.currentProfile : state.airband.currentProfile;
    }
    
    function updateHitList() {
      const header = '<div class="hit-row header"><div>Time</div><div>Src</div><div>Hit</div><div>Dur</div></div>';
      
      if (!state.hits.length) {
        els.hitList.innerHTML = header + '<div class="empty-state"><div class="icon">üìª</div><div>Waiting for hits...</div></div>';
        return;
      }
      
      const rows = state.hits.slice(0, 50).map(hit => {
        const labelRaw = String(hit.label_full || hit.label || hit.freq || '--').trim();
        const isNumeric = /^[0-9]+(\.[0-9]+)?$/.test(labelRaw);
        const hitText = isNumeric
          ? `${formatFreq(labelRaw)} MHz`
          : (abbreviateHitText(labelRaw, 52) || '--');
        const source = (() => {
          const sourceName = String(hit.source || '').trim().toLowerCase();
          if (sourceName === 'digital') return 'DIG';
          if (sourceName === 'airband') return 'AIR';
          if (sourceName === 'ground') return 'GND';
          const type = String(hit.type || '').trim().toLowerCase();
          if (type === 'digital') return 'DIG';
          if (type === 'airband') return 'AIR';
          if (type === 'ground') return 'GND';
          const n = parseFloat(String(hit.freq || ''));
          if (Number.isFinite(n)) {
            if (n >= 118 && n <= 136) return 'AIR';
            return 'GND';
          }
          return '--';
        })();
        const durationVal = Number(hit.duration || 0);
        const durationText = durationVal > 0 ? `${durationVal}s` : (hit.mode ? hit.mode : '--');
        return `
        <div class="hit-row">
          <div class="time">${escapeHtml(hit.time || '--')}</div>
          <div class="src">${escapeHtml(source)}</div>
          <div class="freq" title="${escapeHtml(labelRaw || '--')}">${escapeHtml(hitText)}</div>
          <div class="duration">${escapeHtml(durationText)}</div>
        </div>
      `;
      }).join('');
      
      els.hitList.innerHTML = header + rows;
    }

    function hitKey(hit) {
      if (!hit) return '';
      return [
        String(hit.time || ''),
        String(hit.freq || ''),
        String(hit.type || ''),
        String(hit.tgid || ''),
        String(hit.mode || ''),
      ].join('|');
    }

    function seedHitBaseline(items) {
      sessionHitKeys.clear();
      for (const hit of (items || [])) {
        const key = hitKey(hit);
        if (key) sessionHitKeys.add(key);
      }
      hitBaselineReady = true;
    }
    
    function updateCounters() {
      const elapsed = (Date.now() - state.sessionStart) / 3600000;
      let rate = '--';
      if (elapsed > 0.01 && state.sessionHits > 0) {
        rate = Math.round(state.sessionHits / elapsed);
      }
      
      els.hitCount.textContent = rate;
      els.hitRate.textContent = '';
      
      els.sessionCount.textContent = state.sessionHits;
      
      const startDate = new Date(state.sessionStart);
      els.sessionStart.textContent = 'Since ' + startDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      const allAvoids = [...state.airband.avoids, ...state.ground.avoids];
      const freqs = allAvoids.map(a => a.freq || a);
      let tableHtml = '--';
      if (freqs.length > 0) {
        tableHtml = '<table style="width:100%; font-size:10px; line-height:1.2;">';
        for (let i = 0; i < freqs.length; i += 2) {
          tableHtml += '<tr>';
          tableHtml += '<td style="text-align:left;">' + freqs[i] + '</td>';
          if (i + 1 < freqs.length) {
            tableHtml += '<td style="text-align:left;">' + freqs[i + 1] + '</td>';
          } else {
            tableHtml += '<td></td>';
          }
          tableHtml += '</tr>';
        }
        tableHtml += '</table>';
      }
      els.avoidsCount.innerHTML = tableHtml;
      els.avoidsTarget.textContent = '';
      
      if (state.serverTime) {
        const serverDate = new Date(state.serverTime * 1000);
        els.piTime.textContent = serverDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
      }
      updateSitrep();
    }
    
    function formatFreq(freq) {
      if (!freq) return '--';
      const num = parseFloat(freq);
      return isNaN(num) ? freq : num.toFixed(3);
    }

    function abbreviateHitText(text, maxLen=24) {
      const raw = String(text || '').trim();
      if (!raw) return '';
      if (raw.length <= maxLen) return raw;
      return raw.slice(0, maxLen - 1).trimEnd() + '‚Ä¶';
    }

    function formatDigitalLabel(label) {
      const raw = String(label || '').trim();
      if (!raw) return '--';
      return abbreviateHitText(raw, 18) || '--';
    }

    function formatBytes(bytes) {
      if (bytes === null || bytes === undefined) return '--';
      const b = Number(bytes);
      if (!Number.isFinite(b)) return '--';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let idx = 0;
      let val = b;
      while (val >= 1024 && idx < units.length - 1) {
        val /= 1024;
        idx += 1;
      }
      return `${val.toFixed(val >= 10 ? 0 : 1)} ${units[idx]}`;
    }

    function formatRate(bytesPerSec) {
      if (!Number.isFinite(bytesPerSec)) return '--';
      return `${formatBytes(bytesPerSec)}/s`;
    }

    function formatUptime(seconds) {
      if (!Number.isFinite(seconds)) return '--';
      let s = Math.floor(seconds);
      const days = Math.floor(s / 86400);
      s -= days * 86400;
      const hrs = Math.floor(s / 3600);
      s -= hrs * 3600;
      const mins = Math.floor(s / 60);
      const parts = [];
      if (days) parts.push(`${days}d`);
      if (hrs || days) parts.push(`${hrs}h`);
      parts.push(`${mins}m`);
      return parts.join(' ');
    }

    function formatDurationCompact(ms) {
      if (ms === null || ms === undefined || ms < 0) return '--';
      const totalSec = Math.floor(ms / 1000);
      const hours = Math.floor(totalSec / 3600);
      const minutes = Math.floor((totalSec % 3600) / 60);
      const seconds = totalSec % 60;
      if (hours > 0) return `${hours}h ${minutes}m`;
      if (minutes > 0) return `${minutes}m ${seconds}s`;
      return `${seconds}s`;
    }

    function formatTimeMs(ms) {
      if (!Number.isFinite(ms) || ms <= 0) return '--';
      const d = new Date(ms);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
    }

    function trimServiceNote(value, maxLen = 120) {
      const text = String(value || '').trim();
      if (!text) return '';
      if (text.length <= maxLen) return text;
      return `${text.slice(0, maxLen - 1)}‚Ä¶`;
    }

    function healthTone(stateValue) {
      const s = String(stateValue || '').toLowerCase();
      if (s === 'healthy') return 'good';
      if (s === 'degraded') return 'warn';
      if (s === 'failed') return 'bad';
      return '';
    }

    function summarizePreflight(preflight) {
      const p = preflight || {};
      const reasons = Array.isArray(p.reasons) ? p.reasons : [];
      if (!reasons.length) return '';
      const first = reasons.find(r => String(r.severity || '') === 'critical') || reasons[0];
      if (!first) return '';
      const code = String(first.code || '').trim();
      const message = String(first.message || '').trim();
      if (code && message) return `${code}: ${message}`;
      return code || message || '';
    }

    function formatApiError(res, fallback = '') {
      if (!res) return fallback;
      const base = String(res.error || fallback || '').trim();
      const preflightNote = summarizePreflight(res.preflight);
      if (!preflightNote) return base;
      if (!base) return `Preflight blocked: ${preflightNote}`;
      return `${base} (${preflightNote})`;
    }

    function payloadFromError(err) {
      if (!err || typeof err !== 'object') return null;
      const payload = err.payload;
      return payload && typeof payload === 'object' ? payload : null;
    }

    function messageFromError(err, fallback = '') {
      const payload = payloadFromError(err);
      if (payload) return formatApiError(payload, fallback);
      const text = String(err && err.message ? err.message : '').trim();
      return text || fallback;
    }

    function getProfileLabel(target, id) {
      if (!id) return '--';
      const profiles = state[target]?.profiles || [];
      const match = profiles.find(p => p.id === id);
      return match ? match.label : id;
    }

    function setServiceStatus(key, ok, detail) {
      const row = document.querySelector(`[data-service="${key}"]`);
      const meta = document.getElementById(`service-${key}`);
      if (!row || !meta) return;
      row.classList.toggle('online', ok);
      row.classList.toggle('offline', !ok);
      meta.textContent = detail;
    }

    function setValueTone(el, tone) {
      if (!el) return;
      el.classList.toggle('good', tone === 'good');
      el.classList.toggle('warn', tone === 'warn');
      el.classList.toggle('bad', tone === 'bad');
    }

    function getDongleTelemetry(stats) {
      const dongles = (stats && stats.dongles) ? stats.dongles : {};
      const present = Number(dongles.present_count);
      const target = Number(dongles.target_count);
      const expected = Number(dongles.expected_count);
      const missing = Array.isArray(dongles.missing_expected_serials) ? dongles.missing_expected_serials : [];
      const slow = Array.isArray(dongles.slow_expected_serials) ? dongles.slow_expected_serials : [];
      const minSpeedValue = Number(dongles.min_speed_mbps);
      const minSpeed = Number.isFinite(minSpeedValue) ? minSpeedValue : null;
      const status = String(dongles.status || '').toLowerCase();
      const hasCounts = Number.isFinite(present) && Number.isFinite(target);
      const expectedText = Number.isFinite(expected) && expected > 0 ? ` (cfg ${expected})` : '';
      return {
        hasCounts,
        status,
        missing,
        slow,
        minSpeed,
        summary: hasCounts ? `${present}/${target}${expectedText}` : '--',
      };
    }

    function renderDongleHealth(stats) {
      const info = getDongleTelemetry(stats);
      const statusTone = info.status === 'ideal'
        ? 'good'
        : info.status === 'degraded'
          ? 'warn'
          : info.status === 'critical'
            ? 'bad'
            : '';

      if (els.sitrepDongles) {
        els.sitrepDongles.textContent = info.summary;
        setValueTone(els.sitrepDongles, statusTone);
      }
      if (els.sitrepDonglesMissing) {
        if (info.hasCounts) {
          const missingText = info.missing.length ? `missing: ${info.missing.join(', ')}` : '';
          const slowText = info.slow.length
            ? `slow<${info.minSpeed || '?'}Mbps: ${info.slow.join(', ')}`
            : '';
          const combined = [missingText, slowText].filter(Boolean).join(' | ');
          els.sitrepDonglesMissing.textContent = combined || 'none';
          setValueTone(els.sitrepDonglesMissing, (info.missing.length || info.slow.length) ? 'bad' : 'good');
        } else {
          els.sitrepDonglesMissing.textContent = '--';
          setValueTone(els.sitrepDonglesMissing, '');
        }
      }
      if (els.digitalDongleHealth) {
        els.digitalDongleHealth.textContent = info.summary;
        setValueTone(els.digitalDongleHealth, statusTone);
      }
      if (els.digitalDongleMissing) {
        if (info.hasCounts) {
          const missingText = info.missing.length ? `missing: ${info.missing.join(', ')}` : '';
          const slowText = info.slow.length
            ? `slow<${info.minSpeed || '?'}Mbps: ${info.slow.join(', ')}`
            : '';
          const combined = [missingText, slowText].filter(Boolean).join(' | ');
          els.digitalDongleMissing.textContent = combined || 'none';
          setValueTone(els.digitalDongleMissing, (info.missing.length || info.slow.length) ? 'bad' : 'good');
        } else {
          els.digitalDongleMissing.textContent = '--';
          setValueTone(els.digitalDongleMissing, '');
        }
      }
    }

    function digitalSchedulerStateTone(state) {
      const value = String(state || '').toLowerCase();
      if (value === 'locked') return 'good';
      if (value === 'standby') return '';
      if (value === 'searching' || value === 'inferred' || value === 'degraded') return 'warn';
      if (value === 'failed' || value === 'error') return 'bad';
      return '';
    }

    function formatDigitalSystemHealthRow(row) {
      if (!row || typeof row !== 'object') return '';
      const name = String(row.name || '--').trim() || '--';
      const state = String(row.state || 'unknown').trim().toUpperCase();
      const marker = row.active ? '‚óè' : '‚óã';
      return `${marker} ${name}:${state}`;
    }

    function applyDigitalSchedulerPayload(payload) {
      if (!payload || typeof payload !== 'object') return;
      const d = state.digital;
      d.schedulerMode = payload.digital_scheduler_mode || payload.mode || d.schedulerMode || '';
      d.schedulerActiveSystem = payload.digital_scheduler_active_system || d.schedulerActiveSystem || '';
      d.schedulerNextSystem = payload.digital_scheduler_next_system || d.schedulerNextSystem || '';
      d.schedulerSwitchReason = payload.digital_scheduler_switch_reason || d.schedulerSwitchReason || '';
      d.schedulerLastSwitchTime = Number.isFinite(payload.digital_scheduler_last_switch_time)
        ? payload.digital_scheduler_last_switch_time
        : d.schedulerLastSwitchTime || 0;
      d.schedulerLastApplyError = payload.digital_scheduler_last_apply_error || d.schedulerLastApplyError || '';
      d.schedulerLockTimeoutMs = Number.isFinite(payload.digital_scheduler_lock_timeout_ms)
        ? payload.digital_scheduler_lock_timeout_ms
        : d.schedulerLockTimeoutMs || 0;
      if (Array.isArray(payload.digital_scheduler_system_health)) {
        d.schedulerSystemHealth = payload.digital_scheduler_system_health;
      }
      d.schedulerRaw = payload;
    }

    function applyDigitalPreflightPayload(payload) {
      if (!payload || typeof payload !== 'object') return;
      const d = state.digital;
      if (typeof payload.tuner_busy_count === 'number') {
        d.tunerBusyCount = payload.tuner_busy_count;
      }
      if (typeof payload.playlist_source_ok === 'boolean') {
        d.playlistSourceOk = payload.playlist_source_ok;
      }
      if (typeof payload.playlist_source_type === 'string') {
        d.playlistSourceType = payload.playlist_source_type;
      }
      if (typeof payload.playlist_source_error === 'string') {
        d.playlistSourceError = payload.playlist_source_error;
      }
      d.preflightRaw = payload;
    }

    function healthStateText(rawState) {
      const s = String(rawState || '').toLowerCase();
      if (s === 'healthy') return 'healthy';
      if (s === 'degraded') return 'degraded';
      if (s === 'failed') return 'failed';
      if (s) return s;
      return '--';
    }

    function getDigitalControlChannelHealth() {
      const d = state.digital || {};
      const sourceType = String(d.playlistSourceType || '').trim();
      const metricReady = Boolean(d.controlMetricReady);
      const windowMs = Number.isFinite(d.controlWindowMs) ? Number(d.controlWindowMs) : 0;
      const windowSec = windowMs > 0 ? Math.round(windowMs / 1000) : 0;
      const controlCount = Number.isFinite(d.controlCount) ? Number(d.controlCount) : 0;
      const syncLossCount = Number.isFinite(d.controlSyncLossCount) ? Number(d.controlSyncLossCount) : 0;
      const controlLocked = Boolean(d.controlLocked);
      const lastControlText = formatTimeMs(Number(d.controlLastTime) || 0);

      if (!d.active) {
        return { label: 'OFFLINE', tone: 'bad', detail: 'Digital decoder stopped' };
      }
      if (!d.playlistSourceOk) {
        const reason = d.playlistSourceError ? trimServiceNote(d.playlistSourceError) : 'Playlist source not ready';
        return { label: 'SEARCHING', tone: 'bad', detail: reason };
      }
      if (d.lastError) {
        return { label: 'SEARCHING', tone: 'bad', detail: trimServiceNote(d.lastError) };
      }
      if (metricReady) {
        if (!controlLocked) {
          if (windowSec > 0) {
            return { label: 'SEARCHING', tone: 'bad', detail: `No control-channel decodes in last ${windowSec}s` };
          }
          return { label: 'SEARCHING', tone: 'bad', detail: 'No control-channel decode activity' };
        }
        if (Number(d.tunerBusyCount || 0) > 0) {
          return {
            label: 'DEGRADED',
            tone: 'warn',
            detail: `Control locked; tuner contention (${Number(d.tunerBusyCount || 0)})`,
          };
        }
        if (d.lastWarning) {
          return { label: 'DEGRADED', tone: 'warn', detail: `Control locked; ${trimServiceNote(d.lastWarning)}` };
        }
        const base = windowSec > 0
          ? `Control decode ${controlCount}/${windowSec}s`
          : `Control decode ${controlCount}`;
        const syncTail = syncLossCount > 0 ? `; sync loss ${syncLossCount}` : '';
        return {
          label: 'LOCKED',
          tone: 'good',
          detail: `${base}; last ${lastControlText}${syncTail}`,
        };
      }
      if (Number(d.tunerBusyCount || 0) > 0) {
        return { label: 'DEGRADED', tone: 'warn', detail: `Tuner contention (${Number(d.tunerBusyCount || 0)})` };
      }
      if (d.lastWarning) {
        return { label: 'DEGRADED', tone: 'warn', detail: trimServiceNote(d.lastWarning) };
      }
      if (sourceType) {
        return { label: 'INFERRED', tone: 'warn', detail: `Source: ${sourceType} (direct metric unavailable)` };
      }
      return { label: 'INFERRED', tone: 'warn', detail: 'Direct control metric unavailable' };
    }

    function updateSitrep() {
      if (!els.sitrepUpdated) return;
      const updated = state.serverTime ? new Date(state.serverTime * 1000) : new Date();
      els.sitrepUpdated.textContent = updated.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

      const sessionMs = Date.now() - state.sessionStart;
      els.sitrepSession.textContent = formatDurationCompact(sessionMs);

      const elapsed = sessionMs / 3600000;
      let rate = '--';
      if (elapsed > 0.01 && state.sessionHits > 0) {
        rate = Math.round(state.sessionHits / elapsed);
      }
      if (els.sitrepHitRate) els.sitrepHitRate.textContent = rate;
      if (els.sitrepSessionHits) els.sitrepSessionHits.textContent = state.sessionHits.toString();

      if (els.sitrepLastHit) els.sitrepLastHit.textContent = getLiveDisplayFreq();
      if (els.sitrepLastAirband) {
        els.sitrepLastAirband.textContent = state.lastHitAirband ? `${formatFreq(state.lastHitAirband)} MHz` : '--';
      }
      if (els.sitrepLastGround) {
        els.sitrepLastGround.textContent = state.lastHitGround ? `${formatFreq(state.lastHitGround)} MHz` : '--';
      }

      if (els.sitrepActiveTarget) els.sitrepActiveTarget.textContent = activeTarget.toUpperCase();
      const tuneText = state.tuned && state.tunedFreq ? `${formatFreq(state.tunedFreq)} MHz` : 'Scan';
      if (els.sitrepTune) els.sitrepTune.textContent = tuneText;

      const holdAir = state.hold.airband ? state.hold.airband : '--';
      const holdGround = state.hold.ground ? state.hold.ground : '--';
      const holdDigital = state.hold.digital ? formatDigitalLabel(state.hold.digital.label) : '--';
      if (els.sitrepHold) els.sitrepHold.textContent = `AIR ${holdAir} / GND ${holdGround} / DIG ${holdDigital}`;

      if (els.sitrepAirbandProfile) {
        els.sitrepAirbandProfile.textContent = getProfileLabel('airband', state.airband.currentProfile);
      }
      if (els.sitrepGroundProfile) {
        els.sitrepGroundProfile.textContent = getProfileLabel('ground', state.ground.currentProfile);
      }

      const avoidCount = (state.airband.avoids || []).length + (state.ground.avoids || []).length;
      if (els.sitrepAvoids) els.sitrepAvoids.textContent = avoidCount.toString();

      const airbandAppliedGain = Number.isFinite(state.airband.applied_gain) ? state.airband.applied_gain : null;
      const groundAppliedGain = Number.isFinite(state.ground.applied_gain) ? state.ground.applied_gain : null;
      const airbandAppliedDbfs = Number.isFinite(state.airband.applied_squelch_dbfs) ? state.airband.applied_squelch_dbfs : null;
      const groundAppliedDbfs = Number.isFinite(state.ground.applied_squelch_dbfs) ? state.ground.applied_squelch_dbfs : null;
      if (els.sitrepGainAirband) {
        els.sitrepGainAirband.textContent = Number.isFinite(airbandAppliedGain) ? `${airbandAppliedGain.toFixed(1)} dB` : 'pending';
      }
      if (els.sitrepGainGround) {
        els.sitrepGainGround.textContent = Number.isFinite(groundAppliedGain) ? `${groundAppliedGain.toFixed(1)} dB` : 'pending';
      }
      if (els.sitrepSquelchAirband) {
        els.sitrepSquelchAirband.textContent = Number.isFinite(airbandAppliedDbfs) ? `${Math.round(airbandAppliedDbfs)} dBFS` : 'pending';
      }
      if (els.sitrepSquelchGround) {
        els.sitrepSquelchGround.textContent = Number.isFinite(groundAppliedDbfs) ? `${Math.round(groundAppliedDbfs)} dBFS` : 'pending';
      }
      if (els.sitrepFilterAirband) {
        els.sitrepFilterAirband.textContent = Number.isFinite(state.airband.filter) ? `${state.airband.filter} Hz` : '--';
      }
      if (els.sitrepFilterGround) {
        els.sitrepFilterGround.textContent = Number.isFinite(state.ground.filter) ? `${state.ground.filter} Hz` : '--';
      }
      if (els.sitrepMounts) {
        const mounts = state.icecastMounts || [];
        const expected = state.icecastExpectedMounts || [];
        if (!expected.length) {
          els.sitrepMounts.textContent = mounts.length ? mounts.join(', ') : '--';
        } else {
          const display = expected.map((m) => {
            const label = m.replace(/^\//, '');
            return mounts.includes(m) ? label : `${label} ‚úó`;
          });
          els.sitrepMounts.textContent = display.join('  ');
        }
      }

      const now = Date.now();
      const airbandDelta = state.sdr1LastSeen ? (now - state.sdr1LastSeen) : null;
      const groundDelta = state.sdr2LastSeen ? (now - state.sdr2LastSeen) : null;
      const airbandAge = state.sdr1LastSeen ? formatDurationCompact(airbandDelta) : '--';
      const groundAge = state.sdr2LastSeen ? formatDurationCompact(groundDelta) : '--';
      if (els.sitrepAirbandHeartbeat) {
        if (state.sdr1Active) {
          if (airbandDelta !== null && airbandDelta < 1500) {
            els.sitrepAirbandHeartbeat.textContent = 'active ‚Ä¢ now';
          } else {
            els.sitrepAirbandHeartbeat.textContent = state.sdr1LastSeen ? `active ‚Ä¢ ${airbandAge} ago` : 'active';
          }
        } else {
          els.sitrepAirbandHeartbeat.textContent = state.sdr1LastSeen ? `last ${airbandAge} ago` : '--';
        }
      }
      if (els.sitrepAirbandDot) {
        els.sitrepAirbandDot.classList.toggle('active', Boolean(state.sdr1Active));
      }
      if (els.sitrepGroundHeartbeat) {
        if (state.sdr2Active) {
          if (groundDelta !== null && groundDelta < 1500) {
            els.sitrepGroundHeartbeat.textContent = 'active ‚Ä¢ now';
          } else {
            els.sitrepGroundHeartbeat.textContent = state.sdr2LastSeen ? `active ‚Ä¢ ${groundAge} ago` : 'active';
          }
        } else {
          els.sitrepGroundHeartbeat.textContent = state.sdr2LastSeen ? `last ${groundAge} ago` : '--';
        }
      }
      if (els.sitrepGroundDot) {
        els.sitrepGroundDot.classList.toggle('active', Boolean(state.sdr2Active));
      }

      const tuneMode = state.tuned ? 'Direct Tune' : (state.hold.airband || state.hold.ground || state.hold.digital ? 'Hold' : 'Scan');
      if (els.sitrepTuneMode) els.sitrepTuneMode.textContent = tuneMode;
      if (els.sitrepDigitalProfile) {
        els.sitrepDigitalProfile.textContent = state.digital.profile || state.digital.activeProfile || '--';
      }
      if (els.sitrepDigitalMode) {
        els.sitrepDigitalMode.textContent = state.digital.schedulerMode || '--';
      }
      if (els.sitrepDigitalActiveSystem) {
        const activeName = state.digital.schedulerActiveSystem || '--';
        els.sitrepDigitalActiveSystem.textContent = activeName;
        const activeRow = (state.digital.schedulerSystemHealth || []).find((row) => row && row.active);
        setValueTone(
          els.sitrepDigitalActiveSystem,
          activeRow ? digitalSchedulerStateTone(activeRow.state) : ''
        );
      }
      if (els.sitrepDigitalNextSystem) {
        els.sitrepDigitalNextSystem.textContent = state.digital.schedulerNextSystem || '--';
      }
      if (els.sitrepDigitalSwitch) {
        const base = state.digital.schedulerSwitchReason || '--';
        if (state.digital.schedulerLockTimeoutMs > 0) {
          els.sitrepDigitalSwitch.textContent = `${base} (timeout ${Math.round(state.digital.schedulerLockTimeoutMs / 1000)}s)`;
        } else {
          els.sitrepDigitalSwitch.textContent = base;
        }
      }
      if (els.sitrepDigitalCc) {
        const cc = getDigitalControlChannelHealth();
        els.sitrepDigitalCc.textContent = `${cc.label}${cc.detail ? ` ‚Ä¢ ${cc.detail}` : ''}`;
        setValueTone(els.sitrepDigitalCc, cc.tone);
      }
      if (els.sitrepDigitalSystems) {
        const rows = Array.isArray(state.digital.schedulerSystemHealth) ? state.digital.schedulerSystemHealth : [];
        const summary = rows.map((row) => formatDigitalSystemHealthRow(row)).filter(Boolean).join(' | ');
        els.sitrepDigitalSystems.textContent = summary || '--';
      }

      if (els.sitrepConnection) {
        const ok = Boolean(state.connected);
        els.sitrepConnection.textContent = ok ? 'Core link online' : 'Core link offline';
        els.sitrepConnection.classList.toggle('good', ok);
        els.sitrepConnection.classList.toggle('bad', !ok);
      }

      if (els.sitrepStream) {
        const mounts = state.icecastMounts || [];
        const expected = state.icecastExpectedMounts || [];
        const mountsOk = expected.length ? expected.every(m => mounts.includes(m)) : true;
        const ok = Boolean(state.icecastActive) && mountsOk;
        els.sitrepStream.textContent = ok ? 'Audio stream online' : 'Audio stream offline';
        els.sitrepStream.classList.toggle('good', ok);
        els.sitrepStream.classList.toggle('bad', !ok);
      }

      if (els.sitrepConfig) {
        const cfgState = String(state.health?.subsystems?.config?.state || '').toLowerCase();
        if (cfgState === 'failed') {
          els.sitrepConfig.textContent = 'Config failed';
          els.sitrepConfig.classList.add('bad');
          els.sitrepConfig.classList.remove('good');
        } else if (cfgState === 'degraded') {
          els.sitrepConfig.textContent = 'Config degraded';
          els.sitrepConfig.classList.remove('good');
          els.sitrepConfig.classList.add('bad');
        } else {
          const needsRestart = Boolean(state.rtlRestartRequired);
          const ok = !state.combinedStale && !needsRestart;
          els.sitrepConfig.textContent = needsRestart ? 'Restart required' : (ok ? 'Config synced' : 'Config stale');
          els.sitrepConfig.classList.toggle('good', ok);
          els.sitrepConfig.classList.toggle('bad', !ok || needsRestart);
        }
      }

      const airbandHealthState = String(state.health?.subsystems?.airband?.state || '').toLowerCase();
      const groundHealthState = String(state.health?.subsystems?.ground?.state || '').toLowerCase();
      const digitalHealthState = String(state.health?.subsystems?.digital?.state || '').toLowerCase();
      const airbandOk = airbandHealthState ? airbandHealthState !== 'failed' : Boolean(state.sdr1Active);
      const groundOk = groundHealthState ? groundHealthState !== 'failed' : Boolean(state.sdr2Active);
      const digitalOk = digitalHealthState ? digitalHealthState !== 'failed' : Boolean(state.digital.active);

      setServiceStatus('api', Boolean(state.connected), state.connected ? 'online' : 'offline');
      setServiceStatus('sse', Boolean(state.sseConnected), state.sseConnected ? 'streaming' : 'down');
      setServiceStatus('airband', airbandOk, healthStateText(airbandHealthState));
      setServiceStatus('ground', groundOk, healthStateText(groundHealthState));
      setServiceStatus('digital', digitalOk, healthStateText(digitalHealthState));
      setServiceStatus('icecast', Boolean(state.icecastActive), state.icecastActive ? 'serving' : 'offline');
      const vlcAnalogRunning = Boolean(state.vlc.analog.running);
      const vlcDigitalRunning = Boolean(state.vlc.digital.running);
      const vlcAnyRunning = vlcAnalogRunning || vlcDigitalRunning;
      let vlcDetail = 'stopped';
      if (vlcAnalogRunning && vlcDigitalRunning) {
        vlcDetail = 'analog + digital';
      } else if (vlcAnalogRunning) {
        vlcDetail = 'analog';
      } else if (vlcDigitalRunning) {
        vlcDetail = 'digital';
      }
      setServiceStatus('vlc', vlcAnyRunning, vlcDetail);
      setServiceStatus('adsb', Boolean(state.adsbLoaded), state.adsbLoaded ? 'linked' : 'pending');
      if (els.serviceDigitalNote) {
        const err = state.digital.lastError;
        const warn = state.digital.lastWarning;
        const preflight = state.preflight?.digital || {};
        let note = '';
        let tone = '';
        if (err) {
          note = `Error: ${trimServiceNote(err)}`;
          tone = 'bad';
        } else if (warn) {
          note = `Warn: ${trimServiceNote(warn)}`;
          tone = 'warn';
        } else if (preflight && preflight.state && preflight.state !== 'healthy') {
          const summary = summarizePreflight(preflight);
          note = summary ? `Preflight: ${trimServiceNote(summary)}` : `Preflight: ${preflight.state}`;
          tone = preflight.state === 'failed' ? 'bad' : 'warn';
        }
        els.serviceDigitalNote.textContent = note;
        els.serviceDigitalNote.classList.toggle('bad', tone === 'bad');
        els.serviceDigitalNote.classList.toggle('warn', tone === 'warn');
      }

      const hasStats = Boolean(state.systemStats);
      const stats = state.systemStats || {};
      const cpuF = Number.isFinite(stats.cpu_temp_c) ? (stats.cpu_temp_c * 9 / 5 + 32) : null;
      const gpuF = Number.isFinite(stats.gpu_temp_c) ? (stats.gpu_temp_c * 9 / 5 + 32) : null;
      if (els.sitrepCpuTemp) {
        els.sitrepCpuTemp.textContent = Number.isFinite(cpuF) ? `${cpuF.toFixed(1)}¬∞F` : '--';
      }
      if (els.sitrepGpuTemp) {
        els.sitrepGpuTemp.textContent = Number.isFinite(gpuF) ? `${gpuF.toFixed(1)}¬∞F` : '--';
      }
      if (els.sitrepCpuUsage) {
        els.sitrepCpuUsage.textContent = Number.isFinite(stats.cpu_usage) ? `${stats.cpu_usage.toFixed(0)}%` : '--';
      }
      if (els.sitrepUptime) {
        els.sitrepUptime.textContent = Number.isFinite(stats.uptime_s) ? formatUptime(stats.uptime_s) : '--';
      }
      if (els.sitrepNetRx) {
        els.sitrepNetRx.textContent = hasStats ? formatBytes(stats.net?.rx_bytes || 0) : '--';
      }
      if (els.sitrepNetTx) {
        els.sitrepNetTx.textContent = hasStats ? formatBytes(stats.net?.tx_bytes || 0) : '--';
      }
      if (els.sitrepNetRxRate) {
        els.sitrepNetRxRate.textContent = Number.isFinite(state.system.lastRxRate) ? formatRate(state.system.lastRxRate) : '--';
      }
      if (els.sitrepNetTxRate) {
        els.sitrepNetTxRate.textContent = Number.isFinite(state.system.lastTxRate) ? formatRate(state.system.lastTxRate) : '--';
      }
      renderDongleHealth(stats);
    }

    function renderActivityLog() {
      if (!els.activityLog) return;
      if (!activityLog.length) {
        els.activityLog.innerHTML = '<div class="log-empty">Waiting for events...</div>';
        return;
      }
      els.activityLog.innerHTML = '';
      activityLog.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'log-row';

        const time = document.createElement('span');
        time.className = 'log-time';
        time.textContent = entry.time;

        const level = document.createElement('span');
        level.className = `log-level ${entry.level}`;
        level.textContent = entry.level.toUpperCase();

        const msg = document.createElement('span');
        msg.className = 'log-message';
        msg.textContent = entry.message;

        row.appendChild(time);
        row.appendChild(level);
        row.appendChild(msg);
        els.activityLog.appendChild(row);
      });
    }

    function logActivity(message, level = 'info', key = null) {
      if (!els.activityLog) return;
      const now = Date.now();
      if (key) {
        const last = logDedupe.get(key) || 0;
        if (now - last < LOG_DEDUPE_MS) return;
        logDedupe.set(key, now);
      }
      const stamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
      activityLog.unshift({ time: stamp, level, message });
      if (activityLog.length > MAX_LOG) {
        activityLog.pop();
      }
      renderActivityLog();
    }

    async function restartService(target, label) {
      if (!confirm(`Restart ${label}?`)) return;
      const btnMap = {
        airband: els.btnRestartAirband,
        ground: els.btnRestartGround,
        digital: els.btnRestartDigital,
        icecast: els.btnRestartIcecast,
        keepalive: els.btnRestartKeepalive,
        ui: els.btnRestartUi,
      };
      const btn = btnMap[target];
      if (btn) {
        btn.disabled = true;
      }
      try {
        const res = await postAPI('/api/restart', { target });
        if (!res || !res.ok) {
          logActivity(formatApiError(res, `${label} restart failed`), 'warn', `restart-${target}-fail`);
        } else {
          logActivity(`${label} restart issued`, 'info', `restart-${target}`);
          if (target === 'airband' || target === 'ground') {
            setTimeout(() => reloadAnalogStream('restart'), 500);
          } else if (target === 'digital') {
            setTimeout(() => reloadDigitalStream('restart'), 500);
          }
        }
      } catch (e) {
        console.error('Restart failed:', e);
        logActivity(messageFromError(e, `${label} restart failed`), 'warn', `restart-${target}-error`);
      } finally {
        if (btn) {
          setTimeout(() => { btn.disabled = false; }, 1500);
        }
      }
    }

    function toggleSitrep(force) {
      if (!els.viewMain || !els.viewSitrep) return;
      const targetIsSitrep = typeof force === 'boolean' ? force : currentView !== 'sitrep';
      if (targetIsSitrep && currentView === 'sitrep') return;
      if (!targetIsSitrep && currentView === 'main') return;

      const incoming = targetIsSitrep ? els.viewSitrep : els.viewMain;
      const outgoing = targetIsSitrep ? els.viewMain : els.viewSitrep;

      incoming.classList.remove('hidden', 'flip-out');
      outgoing.classList.remove('flip-in');
      incoming.classList.add('flip-in');
      outgoing.classList.add('flip-out');

      setTimeout(() => {
        outgoing.classList.add('hidden');
        outgoing.classList.remove('flip-out');
        incoming.classList.remove('flip-in');
      }, VIEW_FLIP_MS);

      currentView = targetIsSitrep ? 'sitrep' : 'main';
      document.body.classList.toggle('sitrep-mode', targetIsSitrep);
      if (els.logoToggle) {
        els.logoToggle.setAttribute('aria-pressed', targetIsSitrep ? 'true' : 'false');
        els.logoToggle.title = targetIsSitrep ? 'Back to SB3 controls' : 'Open situation report';
      }
      updateSitrep();
    }

    function updateSystemUI(stats) {
      if (!stats || stats.ok === false) return;
      state.systemStats = stats;
      if (els.sysUptimeTile) els.sysUptimeTile.textContent = formatUptime(stats.uptime_s);
      const cpuF = Number.isFinite(stats.cpu_temp_c) ? (stats.cpu_temp_c * 9 / 5 + 32) : null;
      const gpuF = Number.isFinite(stats.gpu_temp_c) ? (stats.gpu_temp_c * 9 / 5 + 32) : null;
      if (els.sysCpuTemp) {
        els.sysCpuTemp.textContent = Number.isFinite(cpuF) ? `${cpuF.toFixed(1)}¬∞F` : '--';
      }
      if (els.sysGpuTemp) {
        els.sysGpuTemp.textContent = Number.isFinite(gpuF) ? `${gpuF.toFixed(1)}¬∞F` : '--';
      }
      if (els.sysCpuUsage) {
        els.sysCpuUsage.textContent = Number.isFinite(stats.cpu_usage) ? `${stats.cpu_usage.toFixed(0)}%` : '--';
      }
      const net = stats.net || {};
      const rx = Number(net.rx_bytes || 0);
      const tx = Number(net.tx_bytes || 0);
      if (els.sysNetRx) els.sysNetRx.textContent = formatBytes(rx);
      if (els.sysNetTx) els.sysNetTx.textContent = formatBytes(tx);
      const now = Date.now();
      if (state.system.lastNetTs) {
        const dt = (now - state.system.lastNetTs) / 1000;
        if (dt > 0) {
          const rxRate = (rx - state.system.lastRx) / dt;
          const txRate = (tx - state.system.lastTx) / dt;
          state.system.lastRxRate = rxRate;
          state.system.lastTxRate = txRate;
          if (els.sysNetRxRate) els.sysNetRxRate.textContent = formatRate(rxRate);
          if (els.sysNetTxRate) els.sysNetTxRate.textContent = formatRate(txRate);
        }
      }
      state.system.lastNetTs = now;
      state.system.lastRx = rx;
      state.system.lastTx = tx;
      updateSitrep();
    }
    
    function switchTarget(target) {
      activeView = target;
      if (target === 'airband' || target === 'ground') {
        activeTarget = target;
      }
      els.tabAirband.classList.toggle('active', target === 'airband');
      els.tabGround.classList.toggle('active', target === 'ground');
      if (els.tabDigital) els.tabDigital.classList.toggle('active', target === 'digital');
      if (els.controlsAnalog) els.controlsAnalog.classList.toggle('hidden', target === 'digital');
      if (els.controlsDigital) els.controlsDigital.classList.toggle('hidden', target !== 'digital');
      if (els.profilesWidget) els.profilesWidget.classList.toggle('hidden', target === 'digital');
      if (els.digitalProfilesWidget) els.digitalProfilesWidget.classList.toggle('hidden', target !== 'digital');
      if (target !== 'digital') {
        els.gainSlider.classList.remove('dirty');
        els.filterSlider.classList.remove('dirty');
        updateControls();
        updateProfiles();
      } else {
        updateDigitalUI();
        refreshDigitalProfiles(true);
        refreshDigitalListen(true);
      }
      updateTuneButton();
    }
    
    // ============================================
    // SLIDER HANDLERS
    // ============================================
    
    function onGainChange() {
      const idx = parseInt(els.gainSlider.value);
      const gain = gainValueFromIndex(idx);
      els.gainValue.textContent = gain.toFixed(1);
      els.gainSlider.classList.add('dirty');
    }
    
    function onDbfsChange() {
      const val = parseInt(els.dbfsSlider.value);
      els.dbfsValue.textContent = val;
      els.dbfsSlider.classList.add('dirty');
    }

    function onFilterChange() {
      const val = parseInt(els.filterSlider.value);
      els.filterValue.textContent = val;
      els.filterSlider.classList.add('dirty');
    }

    function scheduleApplyRefreshes() {
      if (state.applyTimeout) {
        clearTimeout(state.applyTimeout);
        state.applyTimeout = null;
      }
      const delays = [400, 1200, 2500, 5000];
      let idx = 0;
      const runRefresh = async () => {
        try {
          await refresh();
        } catch (e) {
          console.error('Apply refresh failed:', e);
        }
      };
      runRefresh();
      const queueNext = () => {
        if (idx >= delays.length) {
          state.applyTimeout = null;
          return;
        }
        const delay = delays[idx++];
        state.applyTimeout = setTimeout(async () => {
          await runRefresh();
          queueNext();
        }, delay);
      };
      queueNext();
    }
    
    async function applyGainSql() {
      const gainIdx = parseInt(els.gainSlider.value);
      const gain = gainValueFromIndex(gainIdx);
      let squelchDbfs = parseFloat(els.dbfsSlider.value);
      if (squelchDbfs >= -1) squelchDbfs = -1;
      const analogShouldResume = Boolean(
        els.audioPlayerAnalog
        && (!els.audioPlayerAnalog.paused || els.audioPlayerAnalog.dataset.wantplay === '1')
      );
      if (analogShouldResume && els.audioPlayerAnalog) {
        els.audioPlayerAnalog.dataset.wantplay = '1';
      }
      
      try {
        const res = await postAPI('/api/apply', {
          target: activeTarget,
          gain,
          squelch_mode: 'dbfs',
          squelch_dbfs: squelchDbfs,
        });
        els.gainSlider.classList.remove('dirty');
        els.dbfsSlider.classList.remove('dirty');
        els.gainApplied.textContent = 'pending';
        if (els.dbfsApplied) {
          els.dbfsApplied.textContent = 'pending';
        }
        state[activeTarget].gain = gain;
        state[activeTarget].squelch_mode = 'dbfs';
        state[activeTarget].squelch_dbfs = squelchDbfs;
        state[activeTarget].applied_gain = null;
        state[activeTarget].applied_squelch_dbfs = null;
        if (res && res.restart_ok === false) {
          logActivity('Restart required to apply controls', 'warn', `restart-required-${activeTarget}`);
          if (els.dbfsApplied) els.dbfsApplied.textContent = 'restart';
          if (els.gainApplied) els.gainApplied.textContent = 'restart';
        } else {
          scheduleApplyRefreshes();
          scheduleStreamRecovery('analog', `apply-${activeTarget}`, analogShouldResume);
        }
      } catch (e) {
        console.error('Apply failed:', e);
        logActivity(messageFromError(e, 'Apply failed'), 'warn', `apply-failed-${activeTarget}`);
      }
    }

    async function applyBatch() {
      const gainIdx = parseInt(els.gainSlider.value);
      const gain = gainValueFromIndex(gainIdx);
      let squelchDbfs = parseFloat(els.dbfsSlider.value);
      if (squelchDbfs >= -1) squelchDbfs = -1;
      const cutoff = parseInt(els.filterSlider.value);
      const analogShouldResume = Boolean(
        els.audioPlayerAnalog
        && (!els.audioPlayerAnalog.paused || els.audioPlayerAnalog.dataset.wantplay === '1')
      );
      if (analogShouldResume && els.audioPlayerAnalog) {
        els.audioPlayerAnalog.dataset.wantplay = '1';
      }
      try {
        const res = await postAPI('/api/apply-batch', {
          target: activeTarget,
          gain,
          squelch_mode: 'dbfs',
          squelch_dbfs: squelchDbfs,
          cutoff_hz: cutoff,
        });
        els.gainSlider.classList.remove('dirty');
        els.dbfsSlider.classList.remove('dirty');
        els.filterSlider.classList.remove('dirty');
        els.gainApplied.textContent = 'pending';
        if (els.dbfsApplied) {
          els.dbfsApplied.textContent = 'pending';
        }
        els.filterApplied.textContent = cutoff + ' Hz';
        state[activeTarget].gain = gain;
        state[activeTarget].squelch_mode = 'dbfs';
        state[activeTarget].squelch_dbfs = squelchDbfs;
        state[activeTarget].applied_gain = null;
        state[activeTarget].applied_squelch_dbfs = null;
        state[activeTarget].filter = cutoff;
        if (res && res.restart_ok === false) {
          logActivity('Restart required to apply controls', 'warn', `restart-required-${activeTarget}`);
          if (els.dbfsApplied) els.dbfsApplied.textContent = 'restart';
          if (els.gainApplied) els.gainApplied.textContent = 'restart';
        } else {
          scheduleApplyRefreshes();
          scheduleStreamRecovery('analog', `apply-batch-${activeTarget}`, analogShouldResume);
        }
      } catch (e) {
        console.error('Apply batch failed:', e);
        logActivity(messageFromError(e, 'Batch apply failed'), 'warn', `apply-batch-failed-${activeTarget}`);
      }
    }
    
    async function applyFilter() {
      const cutoff = parseInt(els.filterSlider.value);
      
      try {
        await postAPI('/api/filter', { target: activeTarget, cutoff_hz: cutoff });
        els.filterSlider.classList.remove('dirty');
        els.filterApplied.textContent = cutoff + ' Hz';
        state[activeTarget].filter = cutoff;
      } catch (e) {
        console.error('Filter apply failed:', e);
        logActivity(messageFromError(e, 'Filter apply failed'), 'warn', `filter-failed-${activeTarget}`);
      }
    }
    
    // ============================================
    // ACTIONS
    // ============================================
    
    async function toggleHoldFor(target) {
      if (target === 'digital') {
        if (state.hold.digital) {
          state.hold.digital = null;
          updateStatus();
          updateDigitalUI();
          logActivity('Hold released: Digital', 'info', 'hold-stop-digital');
          return;
        }
        const label = (state.digital.lastLabel || state.lastHitDigital || '').trim();
        if (!label) {
          return;
        }
        const timeMs = Number.isFinite(state.digital.lastTime) && state.digital.lastTime > 0
          ? state.digital.lastTime
          : Date.now();
        state.hold.digital = {
          label,
          timeMs,
          mode: state.digital.lastMode || '',
        };
        updateStatus();
        updateDigitalUI();
        logActivity(`Hold engaged: Digital ${label}`, 'info', `hold-start-digital-${label}`);
        return;
      }
      // Release current hold for this target
      if (state.hold[target]) {
        const label = target === 'airband' ? 'Airband' : 'Ground';
        state.hold[target] = null;
        if (state.streamBaseUrl !== analogStreamUrl()) {
          syncStreamLinks();
        }
        updateStatus();
        try {
          await postAPI('/api/hold', { target, action: 'stop' });
          logActivity(`Hold released: ${label}`, 'info', `hold-stop-${target}`);
        } catch (e) {
          console.error('Hold stop failed:', e);
          refresh();
        }
        return;
      }

      const freqVal = getLiveFreqValueForTarget(target);
      if (freqVal === null || isNaN(freqVal)) {
        return;
      }
      state.hold[target] = formatFreq(freqVal) + ' MHz';
      updateStatus();
      try {
        await postAPI('/api/hold', { target, action: 'start', freq: freqVal });
        const label = target === 'airband' ? 'Airband' : 'Ground';
        logActivity(`Hold engaged: ${label} ${state.hold[target]}`, 'info', `hold-start-${target}-${state.hold[target]}`);
      } catch (e) {
        console.error('Hold start failed:', e);
        state.hold[target] = null;
        updateStatus();
        refresh();
      }
    }

    function promptTuneFreq() {
      return new Promise((resolve) => {
        const backdrop = document.createElement('div');
        backdrop.className = 'modal-backdrop';
        const card = document.createElement('div');
        card.className = 'modal-card';
        card.innerHTML = `
          <h3>Direct Tune (MHz)</h3>
          <input id="tune-input" type="text" inputmode="decimal" pattern="[0-9.]*" autofocus />
          <div class="modal-actions">
            <button class="cancel">Cancel</button>
            <button class="confirm">Tune</button>
          </div>
        `;
        backdrop.appendChild(card);
      document.body.appendChild(backdrop);
      const input = card.querySelector('#tune-input');
      input.value = state.lastHit || '';
      input.focus();
        const cleanup = () => backdrop.remove();
        card.querySelector('.cancel').onclick = () => { cleanup(); resolve(null); };
        card.querySelector('.confirm').onclick = () => {
          const v = input.value.trim();
          cleanup();
          resolve(v || null);
        };
        input.onkeydown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            card.querySelector('.confirm').click();
          } else if (e.key === 'Escape') {
            e.preventDefault();
            card.querySelector('.cancel').click();
          }
        };
      });
    }

    async function restoreTuneOrProfile() {
      try {
        await postAPI('/api/tune-restore', { target: activeTarget });
      } catch (e) {
        console.error('Tune restore failed, falling back to profile:', e);
        const profileId = state.lastProfile[activeTarget];
        if (profileId) {
          await selectProfile(profileId, true);
        }
      }
      state.tuned = false;
      state.tunedFreq = null;
      state.tunedTarget = null;
      state.hold[activeTarget] = null;
      updateStatus();
      updateTuneButton();
      setTimeout(() => {
        refresh();
        refreshHits();
      }, 1500);
    }

    function updateTuneButton() {
      const btn = document.getElementById('btn-tune');
      const hasProfile = Boolean(state.lastProfile[activeTarget]);
      if (state.tuned && hasProfile) {
        btn.textContent = 'Scan';
        btn.title = 'Return to previous profile';
      } else {
        btn.textContent = 'Tune';
        btn.title = 'Direct tune';
      }
      updateSitrep();
    }

    function onTuneButtonClick() {
      if (state.tuned && state.lastProfile[activeTarget]) {
        restoreTuneOrProfile();
        return;
      }
      directTune();
    }

    async function directTune() {
      const raw = await promptTuneFreq();
      if (!raw) return;
      const freq = parseFloat(raw);
      if (!freq || isNaN(freq)) {
        alert('Invalid frequency');
        return;
      }
      try {
        await postAPI('/api/tune', { target: activeTarget, freq });
        state.hits = [];
        state.lastHit = freq.toFixed(3);
        if (activeTarget === 'airband') {
          state.lastHitAirband = state.lastHit;
        } else {
          state.lastHitGround = state.lastHit;
        }
        state.hold[activeTarget] = null;
        state.tuned = true;
        state.tunedFreq = freq.toFixed(3);
        state.tunedTarget = activeTarget;
        state.lastProfile[activeTarget] = state[activeTarget].currentProfile;
        updateStatus();
        updateHitList();
        updateTuneButton();
        const label = activeTarget === 'airband' ? 'Airband' : 'Ground';
        logActivity(`Direct tune: ${label} ${state.tunedFreq} MHz`, 'info', `tune-${activeTarget}-${state.tunedFreq}`);
        // Refresh to pick up new config state
        setTimeout(() => {
          refresh();
          refreshHits();
        }, 1500);
      } catch (e) {
        console.error('Tune failed:', e);
        alert('Tune failed');
      }
    }

    async function selectProfile(id, force = false) {
      try {
        const analogShouldResume = Boolean(
          els.audioPlayerAnalog
          && (!els.audioPlayerAnalog.paused || els.audioPlayerAnalog.dataset.wantplay === '1')
        );
        const t = state[activeTarget];
        if (!force && t.currentProfile === id) {
          return;
        }
        const res = await postAPI('/api/profile', { profile: id, target: activeTarget });
        state.tuned = false;
        state.tunedFreq = null;
        state.tunedTarget = null;
        state.hold[activeTarget] = null;
        state.lastProfile[activeTarget] = id;
        await refresh();
        updateTuneButton();
        const label = activeTarget === 'airband' ? 'Airband' : 'Ground';
        logActivity(`Profile set: ${label} ${getProfileLabel(activeTarget, id)}`, 'info', `profile-${activeTarget}-${id}`);
        if (res && res.restart_ok === false) {
          logActivity('Restart required after profile change', 'warn', `restart-required-profile-${activeTarget}`);
        }
        scheduleStreamRecovery('analog', `profile-${activeTarget}`, analogShouldResume);
      } catch (e) {
        console.error('Profile switch failed:', e);
        logActivity(messageFromError(e, 'Profile switch failed'), 'warn', `profile-failed-${activeTarget}-${id}`);
      }
    }
    
    function reconnectUI() {
      if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
      }
      connectSSE();
      refresh();
      refreshHits();
    }
    
    // ============================================
    // DATA REFRESH
    // ============================================
    
    async function refresh() {
      if (refreshInFlight) return refreshInFlight;
      refreshInFlight = (async () => {
        const wasConnected = state.connected;
        try {
          const [data, profilesData, systemData, schedulerData, digitalPreflightData, profileLoopData] = await Promise.all([
            fetchJSON('/api/status'),
            fetchJSON('/api/profiles'),
            fetchJSON('/api/system'),
            fetchJSON('/api/digital/scheduler').catch(() => null),
            fetchJSON('/api/digital/preflight').catch(() => null),
            fetchJSON('/api/profile-loop').catch(() => null),
          ]);

          const pickNumber = (value, fallback) => (value === 0 || value) ? value : fallback;
          const prevAnalogBase = state.streamBaseUrl;
          const prevDigitalBase = state.digitalStreamBaseUrl;
        
        const airbandPresent = (typeof data.airband_present === 'boolean') ? data.airband_present : true;
        const groundPresent = (typeof data.ground_present === 'boolean') ? data.ground_present : true;
        const airbandActiveSignal = (typeof data.airband_active === 'boolean') ? data.airband_active : null;
        const groundActiveSignal = (typeof data.ground_active === 'boolean') ? data.ground_active : null;
        state.sdr1Active = airbandActiveSignal !== null
          ? Boolean(airbandActiveSignal)
          : Boolean(data.rtl_active && airbandPresent);
        state.sdr2Active = groundActiveSignal !== null
          ? Boolean(groundActiveSignal)
          : Boolean(data.rtl_active && groundPresent);
        state.groundUnitActive = data.ground_unit_active ?? false;
        state.combinedStale = Boolean(data.combined_config_stale);
        state.rtlRestartRequired = Boolean(data.rtl_restart_required);
        state.lastStatusTick = Date.now();
        if (state.sdr1Active) state.sdr1LastSeen = state.lastStatusTick;
        if (state.sdr2Active) state.sdr2LastSeen = state.lastStatusTick;
        state.icecastActive = data.icecast_active;
        state.icecastMounts = Array.isArray(data.icecast_mounts) ? data.icecast_mounts : [];
        state.icecastExpectedMounts = Array.isArray(data.icecast_expected_mounts)
          ? data.icecast_expected_mounts
          : [];
        const port = Number(data.icecast_port);
        if (Number.isFinite(port)) {
          state.icecastPort = port;
        }
        if (typeof data.stream_proxy_enabled === 'boolean') {
          state.streamProxyEnabled = data.stream_proxy_enabled;
        }
        if (typeof data.stream_mount === 'string' && data.stream_mount.trim()) {
          state.streamMount = data.stream_mount.trim();
        }
        if (typeof data.digital_stream_mount === 'string' && data.digital_stream_mount.trim()) {
          state.digitalStreamMount = data.digital_stream_mount.trim();
        } else if (typeof data.stream_mount_digital === 'string' && data.stream_mount_digital.trim()) {
          state.digitalStreamMount = data.stream_mount_digital.trim();
        }
        state.lastHit = data.last_hit || data.last_hit_airband || data.last_hit_ground || '';
        state.lastHitAirband = data.last_hit_airband || '';
        state.lastHitGround = data.last_hit_ground || '';
        state.lastHitAirbandLabel = data.last_hit_airband_label || '';
        state.lastHitGroundLabel = data.last_hit_ground_label || '';
        if (!state.lastProfile.airband && data.profile_airband) {
          state.lastProfile.airband = data.profile_airband;
        }
        if (!state.lastProfile.ground && data.profile_ground) {
          state.lastProfile.ground = data.profile_ground;
        }
        
        state.airband.gain = pickNumber(data.airband_gain, pickNumber(data.gain, 32.8));
        state.airband.squelch_mode = data.airband_squelch_mode || 'dbfs';
        state.airband.squelch_snr = pickNumber(data.airband_squelch_snr, pickNumber(data.airband_squelch, pickNumber(data.squelch, 0.5)));
        state.airband.squelch_dbfs = pickNumber(data.airband_squelch_dbfs, 0);
        state.airband.applied_gain = Number.isFinite(data.airband_applied_gain) ? data.airband_applied_gain : null;
        state.airband.applied_squelch_dbfs = Number.isFinite(data.airband_applied_squelch_dbfs) ? data.airband_applied_squelch_dbfs : null;
        state.airband.squelch = state.airband.squelch_dbfs;
        state.airband.filter = pickNumber(data.airband_filter, 3500);
        state.airband.profiles = profilesData.profiles_airband || [];
        state.airband.currentProfile = profilesData.active_airband_id || data.profile_airband || '';
        state.airband.avoids = data.avoids_airband?.sample || [];
        
        state.ground.gain = pickNumber(data.ground_gain, 32.8);
        state.ground.squelch_mode = data.ground_squelch_mode || 'dbfs';
        state.ground.squelch_snr = pickNumber(data.ground_squelch_snr, pickNumber(data.ground_squelch, 0.5));
        state.ground.squelch_dbfs = pickNumber(data.ground_squelch_dbfs, 0);
        state.ground.applied_gain = Number.isFinite(data.ground_applied_gain) ? data.ground_applied_gain : null;
        state.ground.applied_squelch_dbfs = Number.isFinite(data.ground_applied_squelch_dbfs) ? data.ground_applied_squelch_dbfs : null;
        state.ground.squelch = state.ground.squelch_dbfs;
        state.ground.filter = pickNumber(data.ground_filter, 3500);
        state.ground.profiles = profilesData.profiles_ground || [];
        state.ground.currentProfile = profilesData.active_ground_id || data.profile_ground || '';
        state.ground.avoids = data.avoids_ground?.sample || [];

        state.digital.active = Boolean(data.digital_active);
        state.digital.backend = data.digital_backend || '';
        state.digital.profile = data.digital_profile || '';
        state.digital.lastLabel = data.digital_last_label || '';
        state.digital.lastMode = data.digital_last_mode || '';
        state.digital.lastTime = Number.isFinite(data.digital_last_time) ? data.digital_last_time : 0;
        state.digital.lastError = data.digital_last_error || '';
        state.digital.lastWarning = data.digital_last_warning || '';
        state.digital.playlistSourceOk = Boolean(data.digital_playlist_source_ok);
        state.digital.playlistSourceType = data.digital_playlist_source_type || '';
        state.digital.playlistSourceError = data.digital_playlist_source_error || '';
        state.digital.tunerBusyCount = Number.isFinite(data.digital_tuner_busy_count) ? data.digital_tuner_busy_count : 0;
        state.digital.controlMetricReady = Boolean(data.digital_control_channel_metric_ready);
        state.digital.controlLocked = Boolean(data.digital_control_channel_locked);
        state.digital.controlCount = Number.isFinite(data.digital_control_channel_count) ? data.digital_control_channel_count : 0;
        state.digital.controlLastTime = Number.isFinite(data.digital_control_channel_last_time) ? data.digital_control_channel_last_time : 0;
        state.digital.controlSyncLossCount = Number.isFinite(data.digital_control_sync_loss_count) ? data.digital_control_sync_loss_count : 0;
        state.digital.controlWindowMs = Number.isFinite(data.digital_control_window_ms) ? data.digital_control_window_ms : 0;
        applyDigitalSchedulerPayload(data);
        if (schedulerData && schedulerData.ok) {
          applyDigitalSchedulerPayload(schedulerData);
        }
        if (data.profile_loop && typeof data.profile_loop === 'object') {
          applyProfileLoopPayload(data.profile_loop);
        }
        if (profileLoopData && profileLoopData.ok) {
          applyProfileLoopPayload(profileLoopData);
        }
        if (digitalPreflightData && digitalPreflightData.ok) {
          applyDigitalPreflightPayload(digitalPreflightData);
        }
        state.digital.muted = Boolean(data.digital_muted);
        state.lastHitDigital = state.digital.lastLabel || '';
        {
          const activeProfile = state.digital.activeProfile || state.digital.profile;
          if (activeProfile) {
            if (activeProfile !== state.digitalListen.profile) {
              state.digitalListen.profile = activeProfile;
              state.digitalListen.items = [];
              state.digitalListen.dirty = false;
              digitalListenLoaded = false;
            }
          } else if (state.digitalListen.profile) {
            state.digitalListen.profile = '';
            state.digitalListen.items = [];
            state.digitalListen.dirty = false;
            digitalListenLoaded = false;
          }
        }
        
        state.serverTime = data.server_time;
        state.v3Compile = data.v3_compile || null;
        state.preflight = data.preflight || { airband: null, ground: null, digital: null };
        state.health = data.health || { overall: { state: 'unknown', reasonCodes: [] }, subsystems: {} };
        
        state.connected = true;
        if (!wasConnected) {
          logActivity('API connection restored', 'info', 'api-up');
        }
        const analogBase = analogStreamUrl();
        const digitalBase = digitalStreamUrl();
        if (prevAnalogBase !== analogBase || prevDigitalBase !== digitalBase) {
          syncStreamLinks();
        }
        
        updateStatus();
        updateDigitalUI();
        updateControls();
        updateProfiles();
        updateSystemUI(systemData);
          updateCounters();
          updateTuneButton();
          refreshDigitalProfiles();
          refreshDigitalListen();
        } catch (e) {
          if (wasConnected) {
            logActivity('API connection lost', 'warn', 'api-down');
          }
          state.connected = false;
          updateStatus();
          console.error('Refresh failed:', e);
        }
      })();
      try {
        await refreshInFlight;
      } finally {
        refreshInFlight = null;
      }
    }
    
    async function refreshHits() {
      if (refreshHitsInFlight) return refreshHitsInFlight;
      refreshHitsInFlight = (async () => {
        try {
          const data = await fetchJSON('/api/hits');
          const newHits = data.items || [];
          const prevTop = state.hits[0]?.time;

        // First successful /api/hits call establishes baseline; do not count history.
        if (!hitBaselineReady) {
          state.hits = newHits;
          seedHitBaseline(newHits);
          updateHitList();
          updateCounters();
          updateStatus();
          return;
        }

        let newCount = 0;
        for (const hit of newHits) {
          const key = hitKey(hit);
          if (!key || sessionHitKeys.has(key)) continue;
          sessionHitKeys.add(key);
          newCount += 1;
        }
        if (newCount > 0) {
          state.sessionHits += newCount;
        }
        
        state.hits = newHits;
        updateHitList();
        updateCounters();
        updateStatus();
          if (!state.sseConnected && newHits.length > 0) {
            const topHit = newHits[0];
            if (topHit && topHit.time && topHit.time !== prevTop) {
              const raw = String(topHit.label || topHit.freq || '').trim();
              const isNumeric = /^[0-9]+(\.[0-9]+)?$/.test(raw);
              const label = isNumeric ? `${formatFreq(raw)} MHz` : (raw || '--');
              const detail = topHit.duration ? ` ${topHit.duration}s` : '';
              logActivity(`Hit ${label}${detail}`, 'info', `poll-hit-${topHit.time}-${topHit.freq}`);
            }
          }
        } catch (e) {
          console.error('Hits refresh failed:', e);
        }
      })();
      try {
        await refreshHitsInFlight;
      } finally {
        refreshHitsInFlight = null;
      }
    }
    
    // ============================================
    // SSE STREAM
    // ============================================
    
    function connectSSE() {
      if (state.eventSource) {
        state.eventSource.close();
      }
      state.sseConnected = false;
      const es = new EventSource('/api/stream');
      state.eventSource = es;
      
      es.addEventListener('status', (e) => {
        try {
          const data = JSON.parse(e.data);
          state.sdr1Active = data.rtl_active;
          state.sdr2Active = data.ground_active;
          state.icecastActive = data.icecast_active;
          if (typeof data.ground_unit_active === 'boolean') {
            state.groundUnitActive = data.ground_unit_active;
          }
          if (typeof data.combined_config_stale === 'boolean') {
            state.combinedStale = data.combined_config_stale;
          }
          state.lastHit = data.last_hit || state.lastHit;
          state.serverTime = data.server_time;
          state.lastStatusTick = Date.now();
          if (data.profile_loop && typeof data.profile_loop === 'object') {
            applyProfileLoopPayload(data.profile_loop);
          }
          if (state.sdr1Active) state.sdr1LastSeen = state.lastStatusTick;
          if (state.sdr2Active) state.sdr2LastSeen = state.lastStatusTick;
          state.connected = true;
          updateStatus();
          updateCounters();
        } catch (err) {
          console.error('SSE status parse error:', err);
        }
      });
      
      es.addEventListener('hits', (e) => {
        try {
          const data = JSON.parse(e.data);
          const newHits = data.items || [];
          
          // Only update if SSE has newer data (don't overwrite polling data with less)
          if (newHits.length === 0) return;

          // Wait for /api/hits baseline before counting session events.
          if (!hitBaselineReady) {
            state.hits = newHits.slice(0, 50);
            updateHitList();
            updateStatus();
            return;
          }
          
          // Merge: prepend unseen hits even if they share the same HH:MM:SS timestamp.
          // High-traffic digital bursts often emit many unique hits per second.
          const topHit = newHits[0];
          let added = 0;
          for (let i = newHits.length - 1; i >= 0; i--) {
            const key = hitKey(newHits[i]);
            if (key && !sessionHitKeys.has(key)) {
              state.hits.unshift(newHits[i]);
              sessionHitKeys.add(key);
              added += 1;
            }
          }
          if (added > 0) {
            state.sessionHits += added;
            state.hits = state.hits.slice(0, 50);
            updateHitList();
            updateCounters();
            updateStatus();
            if (topHit && topHit.freq) {
              const raw = String(topHit.label || topHit.freq || '').trim();
              const isNumeric = /^[0-9]+(\.[0-9]+)?$/.test(raw);
              const label = isNumeric ? `${formatFreq(raw)} MHz` : (raw || '--');
              const detail = topHit.duration ? ` ${topHit.duration}s` : '';
              logActivity(`Hit ${label}${detail}`, 'info', `hit-${topHit.time}-${topHit.freq}`);
            }
          }
        } catch (err) {
          console.error('SSE hits parse error:', err);
        }
      });
      
      es.onerror = () => {
        state.sseConnected = false;
        state.connected = false;
        updateStatus();
        updateSitrep();
        logActivity('SSE stream disconnected - retrying', 'warn', 'sse-down');
        es.close();
        state.eventSource = null;
        setTimeout(connectSSE, 3000);
      };
      
      es.onopen = () => {
        state.sseConnected = true;
        state.connected = true;
        updateStatus();
        updateSitrep();
        logActivity('SSE stream connected', 'info', 'sse-open');
      };
    }
    
    // ============================================
    // THEME
    // ============================================
    
    function toggleTheme() {
      document.body.classList.toggle('red-theme');
      const isRed = document.body.classList.contains('red-theme');
      localStorage.setItem('sb3-theme', isRed ? 'red' : 'default');
    }
    
    function loadTheme() {
      const saved = localStorage.getItem('sb3-theme');
      if (saved === 'red') {
        document.body.classList.add('red-theme');
      }
    }
    
    // ============================================
    // INIT
    // ============================================
    
    async function init() {
      loadTheme();
      setupCollapsibleWidgets();
      updateTuneButton();
      setProfileEditorTab('analog');
      setProfileLoopTab(state.profileLoopUi.tab || 'analog');
      refreshProfileEditorOptions();

      syncStreamLinks();
      refreshVlcStatus();
      
      els.gainSlider.addEventListener('input', onGainChange);
      els.dbfsSlider.addEventListener('input', onDbfsChange);
      els.filterSlider.addEventListener('input', onFilterChange);
      els.lastHitAirband.addEventListener('click', () => toggleHoldFor('airband'));
      els.lastHitGround.addEventListener('click', () => toggleHoldFor('ground'));
      if (els.lastHitDigital) {
        els.lastHitDigital.addEventListener('click', () => {
          toggleHoldFor('digital');
        });
      }
      if (els.logoToggle) {
        els.logoToggle.addEventListener('click', () => toggleSitrep());
      }
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && state.profileLoopUi.open) {
          closeProfileLoopSidecar();
          return;
        }
        if (e.key === 'Escape' && state.profileEditor.open) {
          closeProfileEditorSidecar();
          return;
        }
        if (e.key === 'Escape' && currentView === 'sitrep') {
          toggleSitrep(false);
        }
      });
      // Local playback handlers
      if (els.btnPlayAnalog) {
        els.btnPlayAnalog.addEventListener('click', () => toggleVlcPlayback('analog'));
      }
      if (els.btnPlayDigital) {
        els.btnPlayDigital.addEventListener('click', () => toggleVlcPlayback('digital'));
      }
      if (els.btnApply) {
        els.btnApply.addEventListener('click', applyBatch);
      }
      if (els.loopSave) {
        els.loopSave.addEventListener('click', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          applyProfileLoopConfig(target, null);
        });
      }
      if (els.loopToggle) {
        els.loopToggle.addEventListener('click', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          const enabled = Boolean((state.profileLoop[target] || {}).enabled);
          applyProfileLoopConfig(target, !enabled);
        });
      }
      if (els.loopDwell) {
        els.loopDwell.addEventListener('change', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          updateLoopLocalSettingsFromInputs(target);
          scheduleLoopAutoApply(target);
        });
      }
      if (els.loopHang) {
        els.loopHang.addEventListener('change', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          updateLoopLocalSettingsFromInputs(target);
          scheduleLoopAutoApply(target);
        });
      }
      if (els.loopPause) {
        els.loopPause.addEventListener('change', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          updateLoopLocalSettingsFromInputs(target);
          scheduleLoopAutoApply(target);
        });
      }
      if (els.loopSelectAll) {
        els.loopSelectAll.addEventListener('click', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          selectAllLoopProfiles(target, true);
        });
      }
      if (els.loopClear) {
        els.loopClear.addEventListener('click', () => {
          const target = activeTarget === 'ground' ? 'ground' : 'airband';
          selectAllLoopProfiles(target, false);
        });
      }
      document.getElementById('btn-avoid').addEventListener('click', async function() {
        const btn = document.getElementById('btn-avoid');
        btn.disabled = true;
        btn.textContent = 'Avoiding...';
        try {
          await postAPI('/api/avoid', { target: activeTarget });
          await refresh();
          logActivity(`Avoid added for ${activeTarget}`, 'info', `avoid-${activeTarget}`);
          // Refresh again after 2 seconds to catch the config update
          setTimeout(refresh, 2000);
        } catch (e) {
          console.error('Avoid failed:', e);
        }
        btn.disabled = false;
        btn.textContent = 'Avoid';
      });
      document.getElementById('btn-clear-avoids').addEventListener('click', async function() {
        try {
          await postAPI('/api/avoid-clear', { target: activeTarget });
          await refresh();
          logActivity(`Avoids cleared for ${activeTarget}`, 'info', `avoid-clear-${activeTarget}`);
        } catch (e) {
          console.error('Clear avoids failed:', e);
        }
      });
      document.getElementById('btn-tune').addEventListener('click', onTuneButtonClick);
      document.querySelectorAll('button.action').forEach(btn => {
        btn.addEventListener('click', () => setTimeout(() => btn.blur(), 300));
      });
      if (els.digitalStop) {
        els.digitalStop.addEventListener('click', () => runDigitalAction('stop'));
      }
      if (els.digitalRestart) {
        els.digitalRestart.addEventListener('click', () => runDigitalAction('restart'));
      }
      if (els.digitalProfileSelect) {
        els.digitalProfileSelect.addEventListener('change', onDigitalProfileChange);
      }
      if (els.digitalLoopSave) {
        els.digitalLoopSave.addEventListener('click', () => applyProfileLoopConfig('digital', null));
      }
      if (els.digitalLoopToggle) {
        els.digitalLoopToggle.addEventListener('click', () => {
          const enabled = Boolean((state.profileLoop.digital || {}).enabled);
          applyProfileLoopConfig('digital', !enabled);
        });
      }
      if (els.digitalLoopDwell) {
        els.digitalLoopDwell.addEventListener('change', () => {
          updateLoopLocalSettingsFromInputs('digital');
          scheduleLoopAutoApply('digital');
        });
      }
      if (els.digitalLoopHang) {
        els.digitalLoopHang.addEventListener('change', () => {
          updateLoopLocalSettingsFromInputs('digital');
          scheduleLoopAutoApply('digital');
        });
      }
      if (els.digitalLoopPause) {
        els.digitalLoopPause.addEventListener('change', () => {
          updateLoopLocalSettingsFromInputs('digital');
          scheduleLoopAutoApply('digital');
        });
      }
      if (els.digitalLoopSelectAll) {
        els.digitalLoopSelectAll.addEventListener('click', () => selectAllLoopProfiles('digital', true));
      }
      if (els.digitalLoopClear) {
        els.digitalLoopClear.addEventListener('click', () => selectAllLoopProfiles('digital', false));
      }
      if (els.digitalManageCreate) {
        els.digitalManageCreate.addEventListener('click', createDigitalProfile);
      }
      if (els.digitalManageDelete) {
        els.digitalManageDelete.addEventListener('click', deleteDigitalProfile);
      }
      if (els.digitalPreview) {
        const saved = localStorage.getItem('sb3-digital-preview-collapsed');
        if (saved === '1') {
          els.digitalPreview.classList.add('collapsed');
          if (els.digitalPreviewToggle) els.digitalPreviewToggle.textContent = 'Show';
        }
      }
      if (els.digitalPreviewToggle && els.digitalPreview) {
        els.digitalPreviewToggle.addEventListener('click', () => {
          const collapsed = els.digitalPreview.classList.toggle('collapsed');
          els.digitalPreviewToggle.textContent = collapsed ? 'Show' : 'Hide';
          localStorage.setItem('sb3-digital-preview-collapsed', collapsed ? '1' : '0');
        });
      }
      if (els.digitalPreviewLoad) {
        els.digitalPreviewLoad.addEventListener('click', loadDigitalPreview);
      }
      if (els.digitalListen) {
        const saved = localStorage.getItem('sb3-digital-listen-collapsed');
        if (saved === '1') {
          els.digitalListen.classList.add('collapsed');
          if (els.digitalListenToggle) els.digitalListenToggle.textContent = 'Show';
        }
      }
      if (els.digitalListenToggle && els.digitalListen) {
        els.digitalListenToggle.addEventListener('click', () => {
          const collapsed = els.digitalListen.classList.toggle('collapsed');
          els.digitalListenToggle.textContent = collapsed ? 'Show' : 'Hide';
          localStorage.setItem('sb3-digital-listen-collapsed', collapsed ? '1' : '0');
        });
      }
      if (els.digitalListenLoad) {
        els.digitalListenLoad.addEventListener('click', () => refreshDigitalListen(true));
      }
      if (els.digitalListenSave) {
        els.digitalListenSave.addEventListener('click', saveDigitalListen);
      }
      if (els.digitalListenSearch) {
        els.digitalListenSearch.addEventListener('input', (e) => {
          state.digitalListen.search = e.target.value || '';
          renderDigitalListenList();
        });
      }
      if (els.digitalListenFilter) {
        els.digitalListenFilter.addEventListener('change', (e) => {
          state.digitalListen.filter = e.target.value || 'all';
          renderDigitalListenList();
        });
      }
      if (els.digitalListenModeFilter) {
        els.digitalListenModeFilter.addEventListener('change', (e) => {
          state.digitalListen.modeFilter = e.target.value || 'all';
          renderDigitalListenList();
        });
      }
      if (els.digitalListenMuteEncrypted) {
        els.digitalListenMuteEncrypted.addEventListener('click', muteEncryptedTalkgroups);
      }
      if (els.digitalListenEnableFiltered) {
        els.digitalListenEnableFiltered.addEventListener('click', () => setDigitalListenForFiltered(true));
      }
      if (els.digitalListenDisableFiltered) {
        els.digitalListenDisableFiltered.addEventListener('click', () => setDigitalListenForFiltered(false));
      }
      if (els.digitalListenList) {
        els.digitalListenList.addEventListener('click', (e) => {
          const btn = e.target && e.target.closest ? e.target.closest('button[data-sort-key]') : null;
          if (!btn) return;
          const sortKey = btn.getAttribute('data-sort-key') || '';
          setDigitalListenSort(sortKey);
        });
        els.digitalListenList.addEventListener('change', (e) => {
          const target = e.target;
          if (!target || target.tagName !== 'INPUT') return;
          const dec = target.getAttribute('data-dec');
          if (!dec) return;
          const items = state.digitalListen.items || [];
          const item = items.find((row) => String(row.dec) === String(dec));
          if (!item) return;
          item.listen = target.checked;
          state.digitalListen.dirty = true;
          const scrollTop = els.digitalListenList.scrollTop;
          renderDigitalListenList();
          els.digitalListenList.scrollTop = scrollTop;
        });
      }
      if (els.profileEditorOpenAnalog) {
        els.profileEditorOpenAnalog.addEventListener('click', () => openProfileEditorSidecar('analog'));
      }
      if (els.profileEditorOpenDigital) {
        els.profileEditorOpenDigital.addEventListener('click', () => openProfileEditorSidecar('digital'));
      }
      if (els.profileLoopOpenAnalog) {
        els.profileLoopOpenAnalog.addEventListener('click', () => openProfileLoopSidecar('analog'));
      }
      if (els.profileLoopOpenDigital) {
        els.profileLoopOpenDigital.addEventListener('click', () => openProfileLoopSidecar('digital'));
      }
      if (els.profileLoopSidecarClose) {
        els.profileLoopSidecarClose.addEventListener('click', closeProfileLoopSidecar);
      }
      if (els.profileLoopSidecarOverlay) {
        els.profileLoopSidecarOverlay.addEventListener('click', closeProfileLoopSidecar);
      }
      if (els.profileLoopTabAnalog) {
        els.profileLoopTabAnalog.addEventListener('click', () => setProfileLoopTab('analog'));
      }
      if (els.profileLoopTabDigital) {
        els.profileLoopTabDigital.addEventListener('click', () => setProfileLoopTab('digital'));
      }
      if (els.profileLoopRefresh) {
        els.profileLoopRefresh.addEventListener('click', () => refresh());
      }
      if (els.profileSidecarClose) {
        els.profileSidecarClose.addEventListener('click', closeProfileEditorSidecar);
      }
      if (els.profileSidecarOverlay) {
        els.profileSidecarOverlay.addEventListener('click', closeProfileEditorSidecar);
      }
      if (els.profileEditorTabAnalog) {
        els.profileEditorTabAnalog.addEventListener('click', () => setProfileEditorTab('analog'));
      }
      if (els.profileEditorTabDigital) {
        els.profileEditorTabDigital.addEventListener('click', () => setProfileEditorTab('digital'));
      }
      if (els.profileEditorAnalogTarget) {
        els.profileEditorAnalogTarget.addEventListener('change', () => {
          const nextTarget = (els.profileEditorAnalogTarget.value || 'airband') === 'ground' ? 'ground' : 'airband';
          const previousTarget = state.profileEditor.analog.target || 'airband';
          if (nextTarget !== previousTarget && !profileEditorConfirmDiscard('analog', `switching to ${nextTarget}`)) {
            els.profileEditorAnalogTarget.value = previousTarget;
            return;
          }
          state.profileEditor.analog.target = nextTarget;
          if (nextTarget !== previousTarget) {
            setProfileEditorDirty('analog', false);
          }
          refreshProfileEditorOptions();
          setProfileEditorStatus('analog', '', false);
        });
      }
      if (els.profileEditorAnalogProfile) {
        els.profileEditorAnalogProfile.addEventListener('change', () => {
          const selected = els.profileEditorAnalogProfile.value || '';
          const previous = state.profileEditor.analog.profileId || '';
          if (selected !== previous && !profileEditorConfirmDiscard('analog', `switching to ${selected || 'another profile'}`)) {
            els.profileEditorAnalogProfile.value = previous;
            return;
          }
          state.profileEditor.analog.profileId = selected;
          if (selected !== previous) {
            setProfileEditorDirty('analog', false);
          }
          setProfileEditorStatus('analog', '', false);
        });
      }
      if (els.profileEditorDigitalProfile) {
        els.profileEditorDigitalProfile.addEventListener('change', () => {
          const selected = els.profileEditorDigitalProfile.value || '';
          const previous = state.profileEditor.digital.profileId || '';
          if (selected !== previous && !profileEditorConfirmDiscard('digital', `switching to ${selected || 'another profile'}`)) {
            els.profileEditorDigitalProfile.value = previous;
            return;
          }
          state.profileEditor.digital.profileId = selected;
          if (selected !== previous) {
            setProfileEditorDirty('digital', false);
          }
          if (selected !== state.digitalListen.profile) {
            state.digitalListen.items = [];
            state.digitalListen.profile = '';
            state.digitalListen.dirty = false;
            digitalListenLoaded = false;
            renderDigitalListenList();
          }
          setProfileEditorStatus('digital', '', false);
        });
      }
      if (els.profileEditorLoadActive) {
        els.profileEditorLoadActive.addEventListener('click', loadActiveProfileEditorTab);
      }
      if (els.profileEditorNewActive) {
        els.profileEditorNewActive.addEventListener('click', createActiveProfileEditorTab);
      }
      if (els.profileEditorAnalogValidate) {
        els.profileEditorAnalogValidate.addEventListener('click', validateProfileEditorAnalog);
      }
      if (els.profileEditorAnalogSave) {
        els.profileEditorAnalogSave.addEventListener('click', saveProfileEditorAnalog);
      }
      if (els.profileEditorAnalogDelete) {
        els.profileEditorAnalogDelete.addEventListener('click', deleteProfileEditorAnalog);
      }
      if (els.profileEditorDigitalValidate) {
        els.profileEditorDigitalValidate.addEventListener('click', validateProfileEditorDigital);
      }
      if (els.profileEditorDigitalSave) {
        els.profileEditorDigitalSave.addEventListener('click', saveProfileEditorDigital);
      }
      if (els.profileEditorDigitalDelete) {
        els.profileEditorDigitalDelete.addEventListener('click', deleteProfileEditorDigital);
      }
      if (els.profileEditorAnalogModulation) {
        els.profileEditorAnalogModulation.addEventListener('input', () => setProfileEditorDirty('analog', true));
      }
      if (els.profileEditorAnalogBandwidth) {
        els.profileEditorAnalogBandwidth.addEventListener('input', () => setProfileEditorDirty('analog', true));
      }
      if (els.profileEditorAnalogFreqs) {
        els.profileEditorAnalogFreqs.addEventListener('input', () => setProfileEditorDirty('analog', true));
      }
      if (els.profileEditorDigitalControls) {
        els.profileEditorDigitalControls.addEventListener('input', () => setProfileEditorDirty('digital', true));
      }
      if (els.profileEditorDigitalSystems) {
        els.profileEditorDigitalSystems.addEventListener('input', () => setProfileEditorDirty('digital', true));
      }
      if (els.profileEditorDigitalTalkgroups) {
        els.profileEditorDigitalTalkgroups.addEventListener('input', () => setProfileEditorDirty('digital', true));
      }
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && state.profileEditor.open) {
          closeProfileEditorSidecar();
        }
      });
      const adsbFrame = document.getElementById('adsb-frame');
      if (adsbFrame) {
        adsbFrame.addEventListener('load', () => {
          state.adsbLoaded = true;
          updateSitrep();
          logActivity('ADS-B panel linked', 'info', 'adsb');
        });
      }
      if (els.manageTargetAirband) {
        els.manageTargetAirband.addEventListener('change', refreshManageCloneOptions);
        els.manageTargetAirband.addEventListener('change', refreshFreqEditOptions);
      }
      if (els.manageTargetGround) {
        els.manageTargetGround.addEventListener('change', refreshManageCloneOptions);
        els.manageTargetGround.addEventListener('change', refreshFreqEditOptions);
      }
      if (els.manageLabel) {
        els.manageLabel.addEventListener('input', () => {
          if (!els.manageId || els.manageId.value.trim()) return;
          els.manageId.value = sanitizeProfileId(els.manageLabel.value);
        });
      }
      if (els.freqEditToggle && els.freqEditor) {
        const saved = localStorage.getItem('sb3-freq-collapsed');
        if (saved === '1') {
          els.freqEditor.classList.add('collapsed');
          els.freqEditToggle.textContent = 'Show';
        }
        els.freqEditToggle.addEventListener('click', () => {
          const collapsed = els.freqEditor.classList.toggle('collapsed');
          els.freqEditToggle.textContent = collapsed ? 'Show' : 'Hide';
          localStorage.setItem('sb3-freq-collapsed', collapsed ? '1' : '0');
        });
      }
      if (els.manageCreate) {
        els.manageCreate.addEventListener('click', async () => {
          const target = getManageTarget();
          const label = (els.manageLabel && els.manageLabel.value || '').trim();
          let profileId = (els.manageId && els.manageId.value || '').trim();
          if (!profileId) profileId = sanitizeProfileId(label);
          profileId = sanitizeProfileId(profileId);
          if (els.manageId) els.manageId.value = profileId;
          if (!profileId) {
            setManageStatus('Enter an ID or label to create a profile.', true);
            return;
          }
          try {
            const res = await postAPI('/api/profile/create', {
              id: profileId,
              label,
              airband: target === 'airband',
            });
            setManageStatus('Profile created', false);
            await refresh();
            if (res.profile && els.freqEditProfile) {
              els.freqEditProfile.value = res.profile.id;
              if (els.freqEditStatus) els.freqEditStatus.textContent = `Ready to edit: ${res.profile.id}`;
            }
          } catch (e) {
            setManageStatus(messageFromError(e, 'Create failed'), true);
          }
        });
      }
      if (els.manageRename) {
        els.manageRename.addEventListener('click', async () => {
          const profileId = getManageSelectedId();
          const label = (els.manageLabel && els.manageLabel.value || '').trim();
          if (!profileId || !label) return;
          try {
            await postAPI('/api/profile/update', {id: profileId, label});
            setManageStatus('Profile renamed', false);
            refresh();
          } catch (e) {
            setManageStatus(messageFromError(e, 'Rename failed'), true);
          }
        });
      }
      if (els.manageDelete) {
        els.manageDelete.addEventListener('click', async () => {
          const profileId = getManageSelectedId();
          if (!profileId) return;
          if (!confirm(`Delete profile ${profileId}?`)) return;
          try {
            await postAPI('/api/profile/delete', {id: profileId});
            setManageStatus('Profile deleted', false);
            refresh();
          } catch (e) {
            setManageStatus(messageFromError(e, 'Delete failed'), true);
          }
        });
      }
      if (els.btnRestartAirband) {
        els.btnRestartAirband.addEventListener('click', () => restartService('airband', 'Airband'));
      }
      if (els.btnRestartGround) {
        els.btnRestartGround.addEventListener('click', () => restartService('ground', 'Ground'));
      }
      if (els.btnRestartDigital) {
        els.btnRestartDigital.addEventListener('click', () => restartService('digital', 'Digital'));
      }
      if (els.btnRestartIcecast) {
        els.btnRestartIcecast.addEventListener('click', () => restartService('icecast', 'Icecast'));
      }
      if (els.btnRestartKeepalive) {
        els.btnRestartKeepalive.addEventListener('click', () => restartService('keepalive', 'Keepalive'));
      }
      if (els.btnRestartUi) {
        els.btnRestartUi.addEventListener('click', () => restartService('ui', 'UI'));
      }
      if (els.freqEditLoad) {
        els.freqEditLoad.addEventListener('click', async () => {
          const id = els.freqEditProfile && els.freqEditProfile.value;
          if (!id) return;
          try {
            const res = await fetchJSON(`/api/profile?id=${encodeURIComponent(id)}`);
            if (els.freqEditText) els.freqEditText.value = formatFreqsText(res.freqs || [], res.labels || []);
            if (els.freqEditStatus) els.freqEditStatus.textContent = `Loaded: ${id}`;
          } catch (e) {
            if (els.freqEditStatus) els.freqEditStatus.textContent = messageFromError(e, 'Load failed');
          }
        });
      }
      if (els.freqEditSave) {
        els.freqEditSave.addEventListener('click', async () => {
          const id = els.freqEditProfile && els.freqEditProfile.value;
          const freqs_text = (els.freqEditText && els.freqEditText.value || '').trim();
          if (!id) {
            if (els.freqEditStatus) els.freqEditStatus.textContent = 'Pick a profile to save.';
            return;
          }
          if (!freqs_text) {
            if (els.freqEditStatus) els.freqEditStatus.textContent = 'Add at least one frequency before saving.';
            return;
          }
          try {
            const res = await postAPI('/api/profile/update_freqs', {id, freqs_text});
            if (els.freqEditStatus) els.freqEditStatus.textContent = res.changed ? 'Saved (scanner updated)' : 'Saved';
            refresh();
          } catch (e) {
            if (els.freqEditStatus) els.freqEditStatus.textContent = messageFromError(e, 'Save failed');
          }
        });
      }
      // Reconnect button removed
      setupAudioAutoRecover();
      
      logActivity('SB3 UI initialized', 'info', 'init');
      await refresh();
      await refreshHits();
      connectSSE();
      updateSitrep();
      
      // Poll only as fallback when SSE is disconnected.
      setInterval(async () => {
        if (state.sseConnected) return;
        try {
          await refreshHits();
        } catch (e) {
          console.error('Fallback hit poll failed:', e);
        }
      }, 2000);
      setInterval(async () => {
        if (state.sseConnected) return;
        try {
          await refresh();
        } catch (e) {
          console.error('Fallback status poll failed:', e);
        }
      }, 10000);
      // Keep a low-frequency sync while SSE is connected.
      setInterval(async () => {
        if (!state.sseConnected) return;
        try {
          await refresh();
        } catch (e) {
          console.error('Connected status sync failed:', e);
        }
      }, 60000);
    }
    
    init();
  </script>
</body>
</html>
